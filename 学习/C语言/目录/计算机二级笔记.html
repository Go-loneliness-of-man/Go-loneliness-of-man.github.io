<!DOCTYPE html>
<html>

<head>
  <title>计算机二级学习笔记</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="../../H5_ps_php_计算机基础.css">
  <style>
    #nav02{
      position:fixed;
      left:75%;
      top:20px;
    }                                                 /*整个‘代码查找’最外层块元素样式*/
    #nav02 ol{
      padding:0px;
      display:none;
      margin:10px 0px 0px 0px;
      list-style-type:none;
    }                                                 /*ol 列表的一般样式*/
    #nav02 ol div > li{
      border:2px solid rgb(82, 255, 234);
      border-radius:20px;
      padding:5px;
      margin:8px 0px;
      width:190px;
      height:40px;
      text-align:center;
    }                                                /*li的一般样式*/
    #nav02 ol div > li:hover{
      border:4px solid rgb(82, 255, 234);
      border-radius:25px;
      padding:10px;
      width:200px;
      font-size:21px;
    }                                                /*li的指针悬停样式*/
    #nav02 #button{
      border:5px solid rgb(82, 255, 234);
      border-radius:20px;
      padding:12px;
      font-size:25px;
      display:inline-block;
    }                                               /*列表标题的样式*/
    #nav02 #button:active{ padding:14px; }          /*列表标题被点击时的样式*/
    #nav02:hover ol{ display:block; }               /*指针悬停下 ol 列表出现*/
    
    #two2 ol,#three2 ol,#four2 ol,#five2 ol,#six2 ol,#seven2 ol,#eight2 ol,#ten2 ol,#nine2 ol{
      display:none!important;
      position:absolute;
      top:60px;
      right:230px;
      text-align:center;
    }                                               /*内嵌列表:代码项列表的一般样式*/
    #two2 ol li,#three2 ol li,#five2 ol li,#six2 ol li,#seven2 ol li,#eight2 ol li,#ten2 ol li{
      border:2px solid rgb(82, 255, 234);
      border-radius:15px;
      width:200px;
      height:30px;
      padding:0px;
      margin:5px;
    }                                                /*代码项列表的每一项的样式*/
    #two2:hover ol,#three2:hover ol,#five2:hover ol,#six2:hover ol,#seven2:hover ol,#eight2:hover ol,#ten2:hover ol{
      display:inline-block!important;
    }                                                /*代码项列表在指针悬停时出现*/
  </style>
</head>

<body>
  <div id="h1"><span class="smallh1">计算机二级学习笔记</span></div>
  <div id="body">
    <div id="nav02">
      <div id="button">主要代码索引</div>
      <ol>
        <div id="two2">
          <ol><li>函数结构</li></ol>
          <li><a href="#two">第二章</a></li>
        </div>
        <div id="three2">
          <ol>
            <li>printf不同进制输出</li>
            <li>char与int混合运算</li>
          </ol>
          <li><a href="#three">第三章</a></li>
        </div>
        <div id="five2">
          <ol><li>switch使用解析</li></ol>
          <li><a href="#five">第五章</a></li>
        </div>
        <div id="six2">
          <ol>
            <li>for 循环示例</li>
            <li>while 循环示例</li>
            <li>跳出语句 continue</li>
            <li>电子计时器</li>
          </ol>
          <li><a href="#six">第六章</a></li>
        </div>
        <div id="seven2">
          <ol>
            <li>循环打印一维数组</li>
            <li>冒泡排序法</li>
            <li>循环打印二维数组</li>
            <li>二维数组应用</li>
            <li>字符串定义和输入和输出</li>
            <li>字符串比较</li>
          </ol>
          <li><a href="#seven">第七章</a></li>
        </div>
        <div id="eight2">
          <ol><li>产生随机数</li></ol>
          <li><a href="#eight">第八章</a></li>
        </div>
        <div id="ten2">
          <ol>
            <li>利用 & 打印变量地址</li>
            <li>地址传递</li>
            <li style="height:57px;">定义冒泡排序函数（传递数组）</li>
            <li>利用指针变量操作数组</li>
            <li>指针数组示例</li>
          </ol>
          <li><a href="#ten">第十章</a></li>
        </div>
      </ol>
    </div>
    <h2>一、前言</h2>
      <details>
        <summary>考试基本要求</summary>
        报名:<br>
        首先在规定时间内按照全国各个省份的不同，按就近原则报考计算机二级考试。<br>
        考试信息:<br>
        1.科目:语言程序设计类(C、C++、Java、VB、Web、python)、数据库程序设计类(Access、MySQL)、办公软件高级应用(Office),任选一科。<br>
        2.形式:采取上机形式，在120分钟内答题，满分100分。<br>
        3.获证条件: <span class="em">六十分万岁</span>。<br>
        C语言考题格式:<br>
        单项选择40题，每题1分。填空题2~3个，18分。程序改错题2~3个，18分。程序设计一题，24分。<br>
      </details>
      <details>
        <summary>考试内容</summary>
        大约十二处:<br>
        <ol>
          <li>C语言程序结构</li>
          <li>数据类型及运算</li>
          <li>基本语句</li>
          <li>选择结构程序设计</li>
          <li>循环结构程序设计</li>
          <li>数组的定义和引用</li>
          <li>函数</li>
          <li>编译预处理</li>
          <li>指针</li>
          <li>结构体与共用体</li>
          <li>位运算</li>
          <li>文件操作</li>
        </ol>
        考的比较多的是选择、循环结构，而从编译预处理到文件操作这部分内容考的就比较少了。<br>
      </details>
    <h2 id="two">二、C语言程序结构</h2>
      函数是完成特定功能的一个逻辑实现过程。
      <details>
        <summary>主函数</summary>
        即main()函数,一个完整的C程序，有且只能有一个主函数，它是由一个主函数和若干其它函数组成的。<br>
        main()函数是程序的入口，程序从main函数开始执行。<br>
      </details>
      <details>
        <summary>其它函数</summary>
        其它函数可以分为两类:系统函数、用户自定义函数。<br>
        系统函数:即库函数，由编译系统提供，用户不必自己定义这些函数，可以直接使用，例如打印函数printf();<br>
        用户自定义函数:用户自己用一些语句构成的自定义函数，用来实现一些特殊功能。
      </details>
      <details>
        <summary>函数结构</summary>
        观察下面这个程序:
        <code>
          #include&lt;stdio.h&gt;         //#include指令导入头文件，stdio.h是一个文件名，是"标准输入/输出头文件"的缩写
          int main()                      //int表示函数的返回值类型为整形，int后是函数名，每个函数后必带()
          {                               //函数下是大括号，括住函数体
            pritf("Hollo world!\n");      //printf("");函数，其中\n是转义字符，代表换行
            return 0;                     //结束一个函数，并且输出函数的返回值
          }
        </code><br>
        其中//表示单行注释，另外的/**/表示多行注释<br>
        #include后可跟尖括号&lt;&gt;,也可跟双引号"",尖括号&lt;&gt;表示编译器直接按系统指定的路径寻找头文件，而使用双引号代表编译器先在当前目录下
        寻找头文件，如果找不到，编译器会再次按系统指定的默认路径寻找头文件。<br>
        函数后的括号用来为函数传递初始参数( 主函数一般不需要 )，括号内也可以什么都不写或写void代表空类型。<br>
        被大括号 {} 括起来的叫做函数体，也称代码体，函数体中每个语句或函数后都必须加封号";"表示这个语句或函数结束，并且除字符串外程序中所有符号都必须
        使用英文半角字符。<br>
        printf("");函数向标准输出设备打印一个字符串。return 0;语句结束函数，并输出函数的返回值，函数返回值的数据类型受函数类型的限制，主函数一般返
        回值为0，表示程序正常执行。<br>
        C语言源代码文件只是普通的文本文件，但文件扩展名必须是".c",经过编译后变成目标代码文件( .obj )，再通过链接器将其与库函数和启动代码拼接成可执行
        文件(.exe)才能运行。<br>
        int main()和void main()在C中是等价的，但 C++ 中只接受 int main() 这种形式。<br>
      </details>
      <details>
        <summary>C代码风格</summary>
        缩进:即制表符Tab，在记事本中是八个字符的大小，不同编辑器中大小不同，缩进表示层级关系，用来清楚的标识一块内容从哪里开始，在哪里结束。<br>
        标识符命名:标识符即名称，其不能是C语言中的关键字，只能由字母、数字、下划线组成且开头不能是数字，标识符中字母区分大小写。另外标识符的命名应尽量
        做到见名之义。<br>
        注释:程序每一步的目的应是显而易见的，所以不宜加过多的注释，应更多的尝试改进程序。另外，注释大多实际开发中使用的，对于考试就没有必要了，注释写的
        再好也不会给考试加分。
      </details>
    <h2 id="three">三、数据类型及运算</h2>
      <details>
        <summary>C语言的32个关键字</summary>
        数据类型关键字(12个):<br>
        int(整型)、char(字符型)、float(单精度浮点型)、double(双精度浮点型)、long(长整型)、short(短整型)、signed(有符号型，默认的，可以不写)、
        unsigned(无符号型)、struct、union、enum、void<br>
        控制语句关键字(12个):<br>
        if、else、switch、case、default、for、do、while、break(跳出循环)、continue(跳出循环一次)、goto、return<br>
        存储类关键字(5个):<br>
        auto、extern、register、static、const<br>
        其他关键字(3个):<br>
        sizeof、typedef、volatile<br>
        考试中基本不考的有6个:signed、goto、auto、extern、register、volatile
      </details>
      <details>
        <summary>数据类型</summary>
        三大类:基本类型、构造类型、指针类型。<br>
        基本类型:包括整型(int、long、short、long long)、字符型 char、实型(也称浮点型，单精度 float、双精度 double)<br>
        构造类型:包括数组类型、结构类型struct、共用体( 联合 )类型union、枚举类型enum<br>
        指针类型:格式:数据类型 *变量名，用来保存变量的地址，在C语言中很重要，但在二级考试中不是重点。
      </details>
      <details>
        <summary>整型int</summary>
        整型输出占位符:<br>
        <table border="1">
          <tr><th style="width:100px;">占位符</th><th style="width:400px;">作用</th></tr>
          <tr><td>%d</td><td>以10进制输出一个有符号int类型</td></tr>
          <tr><td>%u</td><td>以10进制输出一个无符号int类型</td></tr>
          <tr><td>%o</td><td>以8进制输出一个int类型</td></tr>
          <tr><td>%x</td><td>以16进制输出一个int类型，字母部分小写</td></tr>
          <tr><td>%X</td><td>以16进制输出一个int类型，字母部分大写</td></tr>
        </table>
        进制输出例子:<br>
        <code>
          #include&lt;stdio.h&gt;
          int main()
          {
            int a;
            scanf_s("请输入一个十进制数字%d",&a);
            printf("八进制:%o",a);
            printf("十六进制:%x",a);
            printf("十六进制:%X",a);
            return 0;
          }
        </code><br>
        整型的几种分类:<br>
        short:2字节,用占位符%hd输出<br>
        int:4字节，%d输出<br>
        long:Windows为4字节，Linux32位为4字节，Linux64位为8字节，用占位符%ld输出<br>
        long long:8字节，用占位符%lld输出，long long型是C99标准的内容，考试用的VC6编译器使用的是C89标准，不支持long long型<br>
        一个字节为8位二进制。<br>
        当一个大的数据赋值给一个短的数据类型，就会出现高位丢失。<br>
      </details>
      <details>
        <summary>字符型char</summary>
        char用于存储一个<span class="em">单一的字符</span>，在内存中占用1字节，赋值时要将字符用单引号''括起来,占位符为%c<br>
        char在本质上就是一个1字节大小的整型，它存储时也不是把字符本身放到内存中，而是将该字符对应的ASCⅡ码放到内存中。<br>
        ASCⅡ码中有三个值需要记住:48对应0、65对应A、97对应a<br>
        字符型允许和整型进行计算，例如:<br>
        <code>
          #include&lt;stdio.h&gt;
          int main()
          {
            char a = 'a' , b = 'A';
            printf("%d\n", a-b);
            getchar();
            return 0;
          }
        </code><br>
        运行结果为:32<br>
      </details>
      <details>
        <summary>浮点型float、double</summary>
        double比float更精确。<br>
        float占位符为%f，double占位符为%lf<br>
        打印时会默认打印6位小数，若要控制位数可在%后加上数字，格式:%.数字f，例如%.3f表示保留三位小数。<br>
        当小数位数不够时会进行四舍五入。<br>
        单精度浮点数(float)与双精度浮点数(double)的区别如下:<br>
        (1)在内存中占有的字节数不同,单精度浮点数在内存占4个字节,双精度浮点数在内存占8个字节<br>
        (2)有效数字位数不同,单精度浮点数有效数字8位,双精度浮点数有效数字16位<br>
        (3)所能表示数的范围不同,单精度浮点的表示范围:-3.40E+38 ~ +3.40E+38 , 双精度浮点的表示范围：-1.79E+308 ~ +1.79E+308<br>
        (4)在程序中处理速度不同 , 一般来说 , CPU处理单精度浮点数的速度比处理双精度浮点数快
      </details>
      <details>
        <summary>变量与常量</summary>
        常量:<br>
        常量即不发生改变的量，一般出现在表达式或赋值语句中。<br>
        定义常量:常量可以不定义直接使用，也可以为它定一个名字，格式:#define 常量名;，例如:#define PI=3.14<br>
        常量修饰const:用const修饰一个变量时，该变量被认定为常量，值不能被改变。如const int a = 10;此时a为一个常量。<br>
        变量:<br>
        变量的值可以不断发生变化。<br>
        定义格式:类型 变量名; , 例如int a;<br>
      </details>
      <details>
        <summary>运算符种类、优先级</summary>
        分6类:算术、赋值、比较(关系)、逻辑、位、sizeof运算符。<br>
        <span class="em">算术运算符:</span><br>
        用于处理四则运算，包括+、-、*、/、%、++、--<br>
        除法运算:如果相除的两个数都是整数的话，则结果也为整数，小数部分省略，如9/2 =4，而若两数中有一个为小数 ，结果则为小数，如：9.0/2 = 4.500000。
        取余运算:该运算只适合用两个整数进行取余运算，如：10 % 3 = 1 , 而10.0%3则是错误的 , 运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%
        (-3) = 1 。<br>
        自增与自减运算符:自增运算符为“++”，作用是使变量的值自增1；自减运算符为“--”，作用是使变量值自减1。经常在循环中使用，自增自减运算符有两种使用形
        式:<br>
        1.++(或--)变量：先运算再取值，即变量先自增(或自减)1后再取值<br>
        2.变量++(或--)：先取值再运算，即变量先取值后再自增(或自减)1<br>
        注意：无论是a++还是++a都等同于a=a+1,在表达式执行完毕后a的值都自增了1,无论是a--还是--a都等同于a=a-1,在表达式执行完毕后a的值都自减少1 。<br>
        <span class="em">赋值运算符:</span><br>
        分简单赋值运算符、复杂赋值运算符两种,前者即"=",后者包括+=、-=、*=、/=、%=<br>
        复杂赋值运算符是算术运算符和简单赋值运算符的结合，例如 a += 5;代表 a = a + 5;<br>
        <span class="em">比较(关系)运算符:</span><br>
        用于表达式的比较，判断真假，用 0 或 1 表示。<br>
        包括>、<、>=、<=、==(等于)、!=(不等于)六种。<br>
        <span class="em">逻辑运算符:</span><br>
        包括||(或)、&&(且)、!(非)三种，用法不一，比如限定变量a的范围，a&gt;100&&a&lt;120,相当于100 &lt; a &gt;120(计算机看不懂这种写法)<br>
        ||即数学中的"或",!也一样，并且只要是!一个不为零的值，运算后结果为0，相反!0为1。<br>
        相应的&也可用于判断，例如 a = 0 ，b = 3 ， 则 a && b 的值为 0 。<br>
        相反，a || b 的值为 1 。<br>
        <span class="em">位运算符:</span><br>
        用于处理数据的位运算，<br>
        <span class="em">sizeof运算符:</span><br>
        用于求变量的字节长度<br>
        <span class="em">运算符的优先级:</span>
        比较复杂，用一个表格表示:
        <table border="1">
          <tr><th style="width:80px;">优先级</th><th style="width:100px;">运算符</th><th style="width:200px;">名称或含义</th><th style="width:300px;">使用格式</th><th style="width:100px;">运算方向</th><th style="width:100px;">说明</th></tr>
          <tr><td rowspan="4">1</td><td>[]</td><td>数组下标</td><td>数组名[常量表达式]</td><td rowspan="4">左到右</td><td rowspan="4">----</td></tr>
          <tr><td>()</td><td>圆括号</td><td>(a+b)*(c+d)</td></tr>
          <tr><td>.</td><td>成员选择(对象)</td><td>对象.成员名</td></tr>
          <tr><td>-&gt;</td><td>成员选择(指针)</td><td>对象指针-&gt;成员名</td></tr>
          <tr><td rowspan="9">2</td><td>-</td><td>负号运算符</td><td>-表达式</td><td rowspan="9">右到左</td><td rowspan="7">单目运算符</td></tr>
          <tr><td>~</td><td>按位取反运算符</td><td>~表达式</td></tr>
          <tr><td>++</td><td>自增运算符</td><td>变量++或变量++</td></tr>
          <tr><td>--</td><td>自减运算符</td><td>变量--或变量--</td></tr>
          <tr><td>*</td><td>取值运算符</td><td>*指针变量</td></tr>
          <tr><td>&</td><td>取地址运算符</td><td>&变量名</td></tr>
          <tr><td>!</td><td>逻辑非运算符</td><td>!表达式</td></tr>
          <tr><td>(类型)</td><td>强制类型转换</td><td>(转换类型)表达式</td><td rowspan="2">----</td></tr>
          <tr><td>sizeof</td><td>长度运算符</td><td>sizeof(表达式)</td></tr>
          <tr><td rowspan="3">3</td><td>/</td><td>除</td><td>表达式/表达式</td><td rowspan="3">左到右</td><td rowspan="18">双目运算符</td></tr>
          <tr><td>*</td><td>乘</td><td>表达式*表达式</td></tr>
          <tr><td>%</td><td>取余</td><td>表达式%表达式</td></tr>
          <tr><td rowspan="2">4</td><td>+</td><td>加</td><td>表达式+表达式</td><td rowspan="2">左到右</td></tr>
          <tr><td>-</td><td>减</td><td>表达式-表达式</td></tr>
          <tr><td rowspan="2">5</td><td>&lt;&lt;</td><td>左移</td><td>变量&lt;&lt;表达式</td><td rowspan="2">左到右</td></tr>
          <tr><td>&gt;&gt;</td><td>右移</td><td>变量&gt;&gt;表达式</td></tr>
          <tr><td rowspan="4">6</td><td>&gt;</td><td>大于</td><td></td><td rowspan="4">左到右</td>></tr>
          <tr><td>&gt;=</td><td>大于等于</td><td></td></tr>
          <tr><td>&lt;</td><td>小于</td></tr>
          <tr><td>&lt;=</td><td>小于等于</td><td></td></tr>
          <tr><td rowspan="2">7</td><td>==</td><td>等于</td><td>表达式==表达式</td><td rowspan="2">左到右</td></tr>
          <tr><td>!=</td><td>不等于</td><td>表达式!=表达式</td></tr>
          <tr><td>8</td><td>&</td><td>按位与</td><td>表达式&表达式</td><td>左到右</td></tr>
          <tr><td>9</td><td>^</td><td>按位异或</td><td>表达式^表达式</td><td>左到右</td></tr>
          <tr><td>10</td><td>|</td><td>按位或</td><td>表达式|表达式</td><td>左到右</td></tr>
          <tr><td>11</td><td>&&</td><td>逻辑与</td><td>表达式&&表达式</td><td>左到右</td></tr>
          <tr><td>12</td><td>||</td><td>逻辑或</td><td>表达式||表达式</td><td>左到右</td></tr>
          <tr><td>13</td><td>?:</td><td>条件运算符</td><td>表达式1 ? 表达式2 : 表达式3 </td><td>右到左</td><td>三目运算符</td></tr>
          <tr><td rowspan="11">14</td><td>=</td><td>赋值运算符</td><td>变量=表达式</td><td rowspan="11">右到左</td><td rowspan="12">----</td></tr>
          <tr><td>/=</td><td>除后赋值</td><td>变量/=表达式</td></tr>
          <tr><td>*=</td><td>乘后赋值</td><td>变量*=表达式</td></tr>
          <tr><td>%=</td><td>取余后赋值</td><td>变量%=表达式</td></tr>
          <tr><td>+=</td><td>加后赋值</td><td>变量+=表达式</td></tr>
          <tr><td>-=</td><td>减后赋值</td><td>变量-=表达式</td></tr>
          <tr><td>&lt;&lt;=</td><td>左移后赋值</td><td>变量&lt;&lt;=表达式</td></tr>
          <tr><td>&gt;&gt;=</td><td>右移后赋值</td><td>变量&gt;&gt;=表达式</td></tr>
          <tr><td>&=</td><td>按位与后赋值</td><td>变量&=表达式</td></tr>
          <tr><td>^=</td><td>按位非后赋值</td><td>变量^=表达式</td></tr>
          <tr><td>|=</td><td>按位或后赋值</td><td>变量|=表达式</td></tr>
          <tr><td>15</td><td>,</td><td>逗号运算符</td><td>表达式,表达式,...</td><td>左到右</td></tr>
        </table>
      </details>
      <details>
        <summary>自动类型转换、强制类型转换</summary>
        当不同类型的数据进行混合运算时，就会涉及到类型的转换问题，转换的方式有两种:自动、强制。<br><br>
        自动类型转换:<br>
        指程序编译时编译器自动进行的转换，其遵循的原则是由小到大，即占内存空间小的类型能够转换为占内存空间大的类型,这样可以保证精度不降低，从根本上来
        说，是值域小的转换为值域大的<br>
        一般有,char、short转换为int，signed int转换为 unsigned int,int转换为 long ，long、float转换为 double。<br><br>
        <span>强制类型转换:</span><br>
        如果在必要情况下，也可以强制将变量类型转换为另一种类型，这就要写代码了，格式如下:<br>
        要转换的类型 变量2名 = (要转换的类型)变量1名;<br>
        上边这行的意思就是创建一个变量2，存储变量1的另一种类型。例如:<br>
        float a = 1.3;<br>
        int b = (int)a;<br>
        这样就将浮点型变量a转换为了int类型。要注意，转换后直接省略(不是四舍五入)小数部分，比如上边的 b = 1 。<br>
      </details>
    <h2>四、基本语句、I/O函数</h2>
      <details>
        <summary>基本语句</summary>
        分三类:表达式语句、空语句、复合语句。<br>
        表达式语句:<br>
        即表达式,包括算术表达式、逻辑表达式、赋值表达式、逗号表达式、关系表达式等等。格式为: 表达式;<br>
        空语句:<br>
        什么也不执行的语句，有两种使用形式“;”和“{}”,例如: ;;;;; 就是五条空语句。<br>
        复合语句:<br>
        用大括号将多条语句括起来就称为复合语句，只是为了结构分明。<br>
      </details>
      <details>
        <summary>I/O函数</summary>
        printf()函数:<br>
        printf()是输出函数，要注意的是其输出的占位符格式如下:<br>
        <table border="1">
          <tr><th style="width:100px;">占位符</th><th style="width:200px;">对应数据类型</th><th style="width:400px;">含义</th></tr>
          <tr><td>%hd</td><td>short</td><td>短整型</td></tr>
          <tr><td>%hu</td><td>unsigned short</td><td>无符号短整型</td></tr>
          <tr><td>%o</td><td>unsigned int</td><td>无符号八进制整型</td></tr>
          <tr><td>%u</td><td>unsigned int</td><td>无符号十进制整型，与%d相同</td></tr>
          <tr><td>%x、%X</td><td>unsigned int</td><td>无符号十六进制整型</td></tr>
          <tr><td>%f</td><td>float</td><td>单精度浮点型</td></tr>
          <tr><td>%lf</td><td>double</td><td>双精度浮点型</td></tr>
          <tr><td>%c</td><td>char</td><td>单个字符</td></tr>
          <tr><td>%s</td><td>char</td><td>字符串</td></tr>
          <tr><td>%%</td><td>%</td><td>输出一个%</td></tr>
        </table>
        scanf()函数:<br>
        scanf()是输入函数，另外MS定义了它的安全版本scanf_s()函数，如果你用的是MS的编译器，就要注意它们的区别。<br>
        共同点是，它们都以空格结束一次赋值，例如:<br>
        scanf("%d %c",&a,&b);<br>
        这样就进行了两个变量的赋值，其中&是取地址的意思，含义是将键盘输入的数值放到该变量对应的内存地址中。<br>
        不同点是，scanf_s()函数会检查边界，当它获取一个字符串时，需要两个参数，这个额外的参数用来限制字符串的最大长度。例如:<br>
        scanf_s("%s",&a,100);<br>
        这代表将该字符串赋给a，而且由于要读取一个回车符来结束scanf_s()函数，a的最大长度不能超过99。<br><br>
        PS:一个汉字代表两个字符。
      </details>
    <h2 id="five">五、选择结构</h2>
      程序运行的三大类型结构有顺序、选择、循环，这是其中的选择结构。
      <details>
        <summary>if语句</summary>
        格式:<br><br>if(表达式){ 执行代码块; }<br><br>
        语义:如果表达式的值非零，就执行代码块，否则不执行。<br>
        如果执行代码块只有一行，可以不加大括号。<br>
        如果要使if语句覆盖更大的范围，拥有更多的选择，可在其后加一个else，格式如下:<br><br>
        if(表达式){ 执行代码块1; } else{ 执行代码块2; }<br><br>
        语义:如果表达式的值非零，就执行代码块1，否则执行代码块2。<br>
        if语句还可以有更大的空间，只需要再加多个else if()即可，格式如下:<br><br>
        if(表达式1){ 执行代码块1; } else if(表达式2){ 执行代码块2; } else if(表达式3){ 执行代码块3; } .......(无限个) else if(表达式n){ 
        执行代码块n; } ......(又是无限个) else{执行代码块n+n; }<br><br>
        语义很明显:依次判断表达式的值，只要遇到非零，就执行对应代码块然后跳出当前选择结构，否则一直向下执行，如果到最后都不满足表达式，执行else对应的
        代码块。<br>
        如果不需要,else可以被省略。<br>
        if 语句通常适用于判断一个范围性的条件，例如判断 x 是否属于 x &gt; 100 && x &lt; 200 这样的，如果是对应单个的值，一般使用switch语句。
      </details>
      <details>
        <summary>switch语句</summary>
        格式: switch(表达式){ case 1: 执行代码块1; case 2: 执行代码块2; ... case n: 执行代码块n; ... default: 执行代码块n+n}<br>
        语句:判断表达式最终运算的值，根据值来选择对应的 case ，例如值为 2 就执行 case 2: 对应的代码块2，如果没有满足的 case 值，就执行 default 
        对应的代码块。<br>
        与if语句类似，default也是可以被省略的。并且表达式也可以是变量，甚至可以是字符变量，只要为 case 设置对应的字符即可。<br>
        值得注意的是，switch不会像 if 语句那样执行完一个分支后自动结束，它需要在每个执行代码块后加一个跳出语句 break; 来结束，如果不写就会依次执行
        之后的 case 直到遇到 break; 或 default: 。例如下面这个程序:
        <code>
          #include&lt;stdio.h&gt;
          int main()
          { 
            int score;
            printf("\n 请输入成绩: ");
            scanf_s("%d",&score);
            //switch语句
            switch (score/10 % 10)
            {
              case 1:
                printf("\n补考！继续努力！1\n\n ");
              case 2:
                printf("\n 补考！继续努力！2\n\n ");
              case 3:
                printf("\n 补考！继续努力！3\n\n ");
              case 4:
                printf("\n 补考！继续努力！4\n\n");
              case 5:
                printf("\n 补考！继续努力！5\n\n ");
              case 6:
                printf("\n 及格6\n\n ");
              case 7:
                printf("\n 及格7\n\n ");
              case 8:
                printf("\n良好8\n\n ");
              case 9:
                printf("\n 优秀9\n\n ");
              case 0:
                if (score == 100)
                  printf("\n 优秀10\n\n ");
                else
                  printf("\n 补考！继续努力！11\n\n");
              default:
                printf("\n 请重新输入!12\n\n "); }
            return 0;
          }
        </code>
        如果输入34，那么你会得到结果:<br>
        补考！继续努力！3<br>
        补考！继续努力！4<br>
        补考！继续努力！5<br>
        及格6<br>
        及格7<br>
        良好8<br>
        优秀9<br>
        补考！继续努力！11<br>
        请重新输入!12<br>
        可以看出，因为没有写 break; 用来跳出，switch 执行了 case 3 后所有的 case 和 default ，虽然这很糟糕，不过有时也可以利用这一特点起到一些
        意想不到作用，这就要看具体是如何应用了。<br>
      </details>
      选择结构可以互相嵌套，这样就可以设置多层条件判断来解决更复杂的问题，不过嵌套最好不要超过三层，不然这个代码的逻辑就比较烂了。<br>
      <details>
        <summary>三目运算符</summary>
        三目运算符就相当于一个if-else语句,格式如下:<br><br>
        表达式 ? 语句1 : 语句2<br><br>
        语义:表达式的值是否非零?如果是，执行语句1，否则执行语句2。<br>
        三目运算符的优点是结构清晰、体量小、比if语句精简，同时它也可以放在printf()或return等函数或语句中作为参数或值来使用，缩短代码。<br>
      </details>
    <h2 id="six">六、循环结构</h2>
      <details>
        <summary>for循环</summary>
        格式:<br><br>
        for( 变量初始化 ; 条件表达式 ; 处理变量 ){ 循环体 }<br><br>
        语义:首先对循环中用到的变量的值进行初始化，然后根据条件表达式的值决定是否非零，非零则执行循环体，然后处理变量，这算一次循环。一次循环后回到条件
        表达式判断其值，若值非零则执行循环体，处理变量......直到条件表达式值为0。<br>
        例子:
        <code>
          #include&lt;stdio.h&gt;
          // 100 以内遇到 7 的倍数或个位或十位里带数字 7 的数字，输出“敲桌子”
          int i;
          int main()
          {
            for( i = 1 ; i <= 100 ; i++ )
            {
              if( i % 7 == 0 || i % 10 == 7 || i / 10 == 7 )        // %、== 的优先级高于 ||
                printf("敲桌子\n");
              else
                printf("%d\n", i );
            }
            return 0;
          }
        </code>
      </details>
      <details>
        <summary>While 与 do-while 循环</summary>
        格式:<br><br>
        while( 条件表达式 ){ 循环体 }<br><br>
        语义:条件表达式值非零，执行循环体一次，然后再判断，再执行......直到条件不成立。<br>
        例子:
        <code>
          #include&lt;stdio.h&gt;
          /*找出 100 到 1000 内的水仙花数。水仙花数:个位、十位、百位的数字的立方和相加等于其本身的数字，即 本身 = 个位数字三次方 + 十位数字三次
          方 + 百位数字三次方。*/
          int i = 100 , x , y , z;
          int main()
          {
            while(i >= 100 && i <= 1000 )
            {
              x = i % 10;
              y = i / 10 % 10;                        // / 的优先级高于 %
              z = i / 100 % 10;
              if( i == x * x * x + y * y * y + z * z * z )
                printf("水仙花数: %d\n",i);
              i++;
            }
            return 0;
          }
        </code><br>
        <span class="em">do-while:</span><br>
        格式:<br><br>
        do{ 循环体 }while(条件表达式)<br><br>
        语义:do-while与while的唯一区别是，它是先执行循环体然后再看条件表达式的值，所以它有一个特点是至少会执行一次循环体。<br>
        PS:<br>
        死循环:当一个循环的条件表达式值永远为非零时，该循环就陷入死循环,不过死循环可以用跳出语句来结束。
      </details>
      <details>
        <summary>循环跳出语句</summary>
        循环跳出语句用来在循环中实现一些特殊情况，C语言中有两个: break 、 continue<br>
        break:完全跳出当前循环。<br>
        continue:跳过本次循环的<span class="em">循环体</span>，开始下一次循环。<br>
        这两个语句一般配合选择结构在循环中使用。<br>
        continue的一个示例:
        <code>
          #include&lt;stdio.h&gt;
          //打印100以内所有偶数
          int i;
          int main()
          {
            for ( i = 0 ; i < 100 ; i++ )
            {
              if (i % 2 == 1 || i == 0)             //当 i 为 0 或奇数时跳过
                continue;
              printf("%d\n", i);
            }
            return 0;
          }
        </code><br>
        关于上边这个，思考一下如果将 i++ 放在循环体中会出现什么情况 ? 有几种位置? 不同位置的情况分别是什么 ?<br>
        PS: 可以有4个位置。
      </details>
      <details>
        <summary>循环嵌套</summary>
        循环也可以互相嵌套，并且循环嵌套后，可以让子循环在父循环的一个状态(即一次循环)下进行操作，这样就能实现一些稍微复杂的效果。<br>
        例子:
        <code>
          #include&lt;stdio.h&gt;
          #include&lt;Windows.h&gt;    //Sleep() 的头文件
          #include&lt;stdlib.h&gt;     //system() 的头文件
          //电子计时器
          int h, m, s;
          int main()
          {
            for (h = 0; h < 24; h++)
            {
              for (m = 0; m < 60; m++)
              {
                for (s = 0; s < 60; s++)
                {
                  printf("计时: %d : %d : %d\n", h, m, s);
                  Sleep(980);         //Windows系统函数，代表延迟 980ms ,不是 1000ms 的原因是程序运行也需要时间
                  system("cls");	//系统指令，清屏
                }
              }
            }
            return 0;
          }
        </code><br>
        这是个 for 循环的三层嵌套，可以看出，h 每自增一次，m 自增60次，s 自增3600次。j 每60次 自增，都是在 i 的同一状态下进行的，同样，k 的每
        60次自增，都是在 j 的同一状态下进行的，k 的每3600次自增，是在 i 的同一状态下进行的。<br>
        Sleep() 和 system() 是两个系统函数，作用分别是延迟操作和清屏。
      </details>
    <h2 id="seven">七、数组与冒泡排序</h2>
      <details>
        <summary>一维数组的定义、使用</summary>
        数组属于构造数据类型，<span class="em">数组就是内存中一串连续的相同类型的变量空间</span>，同一数组的所有数组元素都是相同类型的，在内存中的
        地址是连续排列的。<br>
        一个数组包含多个数组元素，这些数组元素可以是基本数据类型，也可以是构造类型。<br>
        声明格式:<br><br>
        数据类型 数组名[];<br><br>
        数据类型 数组名[] = { x,x,x,x,x,x,x };<br><br>
        数据类型 数组名[数组元素个数];<br><br>
        数据类型 数组名[数组元素个数] = { x,x,x,x,x,x,x };<br><br>
        以上格式都是可以的，前两个和后两个的区别是，没有事先声明数组元素的个数，这样会<span class="em">在为数组赋值的时候再创建对应个数的内存空间,
        </span>（但若是在程序执行后才赋值便不能这样做了）而后两个事先声明了个数就代表提前创建好了变量，在进行赋值前，它们的初始值是0。第2个和第4个是
        在声明的同时进行赋值。<br>
        使用:<br>
        数组元素的命名是从 0 开始的，所以如果你声明了10个，那么数组元素应该排到编号 9，即 数组名[9]。<br>
        使用时写出对应的数组元素名即可: 数组[数组编号];<br>
        利用循环打印整个数组:
        <code>
          int arr[] = { 1,2,3,4,5 },i = 0;
          while(i < 4)
          {
            printf("%d",arr[i]);
            i++;
          }
        </code><br>
        这样就可以打印整个数组，同样的，利用循环，也可以用一个代码为多个数组元素赋值。
      </details>
      <details>
        <summary>一维数组的常见错误</summary>
        1. 命名规范: 字母(区分大小写)、数字、下划线<br>
        2. 赋值规范: 数组名 = xxx; 这种赋值方法在C语言中是错误的，必须要写出对应的数组元素编号,为某一数组元素赋值。<br>
        3. C语言不支持动态数组，即不支持: 数组类型 数组名[变量名]; 这样的声明格式，所以在声明它时数组元素的个数必须是常量，不能是变量。原因是C语言的
        数组必须在编译前就定义好数组的长度，不能在执行后再定义。
      </details>
      <details>
        <summary>冒泡排序法</summary>
        冒泡排序法，所谓冒泡，就是在一个数组中从头开始依次比较两个数的大小，若前者大于后者就交换位置，这个过程被形象化的比喻为冒泡。<br>
        以下是冒泡排序法的代码实现。
        <code>
          #include&lt;stdio.h&gt;
          //冒泡排序法
          int nums[10], i, i2, x;			       	//定义存储数字的数组 nums[]、循环变量 i和i2、临时变量x
          int main()
          {
            printf("请输入 10 个数字,每个用空格隔开:\n");
            for (i = 0; i < 10; i++) { scanf_s("%d", &nums[i]); }  //将数字读入数组
            for (i = 0; i < 9; i++)
            {
              for (i2 = 0; i2 < 10 - 1 - i; i2++)	       	//注意，一共交换 10-1-i 次,因为需要交换的次数随着遍历次数的增加而减少了
              {
                if (nums[i2] > nums[i2 + 1])
                {
                  x = nums[i2 + 1];
                  nums[i2 + 1] = nums[i2];
                  nums[i2] = x;
                }		        		 	//比较相邻的两个数组元素，若前者大于后者，交换位置
              }			        		 	//遍历数组一次，将一个最大值交换到数组的末尾
            }				                   	//遍历数组九次，将所有数组元素交换排序
            for (i = 0; i < 10; i++) { printf("%d <= ", nums[i]); }	//依次打印数组元素
            printf("\n");
          }
        </code><br>
        思路:<br>
        读入、打印就不说了。<br>
        核心思想是，比较两个数组元素，若前者大于后者，则交换位置，用 if 实现;	( 12 ~ 17行 )<br>
        将 if 放入一个 for 中遍历 nums[] 一次，将此次遍历找到的数组最大者交换到数组的末尾;	( 10 ~ 18行 )<br>
        将以上步骤（遍历 nums[] 一次将数组中最大者交换到末尾）再放入一个 for 中，遍历九次，就可以将所有的数组元素交换排序	（ 8 ~ 19行 ）<br>
        一句话总结:逐个、依次交换排序<br>
        PS: if 的条件表达式决定了排序的方向，若是 &gt; 从小到大，反之从大到小
      </details>
      <details>
        <summary>二维数组的声明、使用</summary>
        <sapn class="em">声明:</sapn><br>
        二维数组的每一行相当于一个一维数组，声明格式:
        <code>
          数据类型 数组名[行数][每一行数组元素的个数] =
          {
            {xx,xx,...,xx,xx},
            {xx,xx,...,xx,xx},
            .
            .
            .
            {xx,xx,...,xx,xx}
          };
        </code><br>
        注意格式，除最后一行外每行后有逗号。<br>
        <span class="em">使用:</span><br>
        可以用两个循环嵌套打印:
        <code>
          #include&lt;stdio.h&gt;
          int nums[3][4] = 
          {
            {1,2,3,4},
            {2,3,4,5},
            {3,4,5,6}
          }, i, i2;
          int main()
          {
            for(i=0;i<3;i++)
            {
              for(i2=0;i2<4;i2++)
              {
                printf("%d ",nums[i][i2]);    //需要写出第 i 行、编号为 i2 才能取出对应数组元素
              }                               //打印一行
              printf("\n");                   //换行
            }                                 //循环三次，将三行都打印出来
          }
        </code><br>
        例题:
        <code>
          #include&lt;stdio.h&gt;
          //四名学生，求其三门课的总成绩和各学科的总成绩
          int sorce[4][3] =
          {
            { 88,99,100 },					//每行代表一名学生，每列代表一门课
            { 36,42,59 },
            { 60,62,54 },
            { 75,97,23 }
          }, i, i2, sum1 = 0, sum2 = 0;                       //定义二维数组、循环变量i和i2、一名学生总成绩sum1、一门课总成绩sum2
          int main()
          {
            for (i = 0; i < 4; i++)
            {
              for (i2 = 0; i2 < 3; i2++)
              {
                sum1 += sorce[i][i2];				//将一行的所有数组元素相加
              }
              printf("学生 %d 三门课的总成绩是: %d\n", i + 1, sum1);
              sum1 = 0;
            }							//求出每名学生三门课的总成绩

            for (i = 0; i < 3; i++)
            {
              for (i2 = 0; i2 < 4; i2++)
              {
                sum2 += sorce[i2][i];				//将一列的所有数组元素相加
              }
              printf("三名学生第 %d 门课的总成绩是: %d\n", i + 1, sum2);
              sum2 = 0;
            }							//求出每门课三名学生的总成绩
          }
        </code><br>
        这里求两个问题分别用了两个嵌套两层的 for 循环，这两个嵌套的原理是一样的，只是将数字稍微改变。第一个是行数不变，将每一行的数组元素循环相加，第
        二个是列数不变，将每一列的数组元素循环相加。
      </details>
      <details>
        <summary>字符串与字符数组</summary>
        严格的说C语言中没有字符串这种数据类型，但可以用字符数组代替，<span class="em">字符串是字符数组的子集</span>,当字符数组以'\0'结尾时,它就是
        字符串，即:<br>
        char arr[11] = { 'H','e','l','l','o','W','o','r','l','d','\0' };<br>
        C 语言对于字符串有简便写法，上面的写法等价于<br>
        char arr[11] = "HelloWorld";<br>
        编译器会自动为上面的写法的末尾添加 '\0' ，因此上面数组的长度是 11 而不是 10。<br>
        字符串与字符是不同的，比如 char arr = 'a' 和 char arr[] = "a" 是不同的，前者只有一个字符，而后者是两个( 'a' 和 '\0' )<br><br>
        字符串与字符数组的输出方式也不同，字符数组要一个一个的输出，因此要借助循环。
        <code>
          char arr[10] = { 'H','e','l','l','o','W','o','r','l','d' };
          for(i = 0; i < 10; i++)
          {
            printf("%c",arr[i]);
          }
        </code><br>
        而字符串不必这么麻烦,可以直接整体输出:
        <code>
          char arr[11] = "HelloWorld";
          printf("%s",arr);
        </code><br>
        两行即可，其中的 %s 是字符串的占位符,另外，printf() 的运行方式是读到 '\0' 即停止输出。<br><br>
        字符串的赋值方式。<br>
        一般可以用 get()（MS的编译器是 gets_s()） 来赋值，如果用 scanf()（MS的编译器是 scanf_s） 为字符串赋值，那么字符串内就不能含有空格，因为
        scanf() 读取缓存区时遇到空格或换行就会结束一次读取，而 get() 不会。<br>
        使用 scanf_s() 的例子:
        <code>
          char arr[100];
          scanf_s("%s",&arr,100);
          printf("%s",arr);
        </code><br>
        使用 gets_s() 的例子:
        <code>
          char arr[100];
          gets_s(arr,100);
          printf("%s",arr);
        </code><br>
        上边数组的长度是字符串的最大长度，只要不超过最大长度即可正常运行，另外， get() 和 scanf() 函数只需要一个参数。
      </details>
      <details>
        <summary>字符串比较</summary>
        考试中常考的一类题,比较两字符串是否相同,代码如下:
        <code>
          #include&lt;stdio.h&gt;
          //字符串比较
          int main()
          {
            char arr1[12] = "Hello world", arr2[12] = "Hallo world";	//定义两字符串
            int i;				                    	//定义循环变量
            for (i = 0; arr1[i] == arr2[i]; i++)			//只要两字符串对应字符相同，就继续循环
            {
              if (arr1[i] == '\0' && arr2[i] == '\0')			//当读到 '\0' 时，代表相同，同时，两字符串的长度也相同
              {
                printf("两个字符串相同\n");
                return 0;				        	//用 return 0; 结束 main() 函数
              }
            }
            printf("两个字符串不相同\n");		         	//循环在未读完字符串时结束，不相同
            return 0;
          }
        </code><br>
        只要两字符串相同，就继续循环，当读到 '\0' 时，代表读完且此前的字符一直相同,那么两字符串相同，输出结果，直接用 return 0; 语句结束 main() 函
        数。而若读到不同的部分，循环结束，输出判断结果 "两个字符串不相同" 。
      </details>
    <h2 id="eight">八、函数</h2>
      <details>
        <summary>函数的介绍</summary>
        函数是 C 程序的基本模块，程序是从主函数 main() 开始执行的。<br>
        以函数的定义看，函数分系统函数( 库函数 )、用户自定义函数两类:<br>
        库函数: 库函数是由编译系统提供的，用户可以直接使用它，例如 printf();，库函数使用时，要事先导入头文件，因为它们的定义就在头文件中。<br>
        用户自定义函数:是用户根据一定的规范，自己编写的函数，以便调用使用完成特定的功能。<br>
      </details>
      <details>
        <summary>随机数</summary>
        这是常考的一类题型<br>
        产生随机数需要用到库函数 rand() 和 srand(),它们在头文件 stdlib.h 中，原本产生随机数只需要 rand()（它是一个产生随机数的封装算法）,但这样
        它只能产生一个一次性的随机数，因为 rand() 还有一个随机数种子的概念，要想多次产生不同的随机数就要不断改变随机数种子(默认恒为 1 )，这就要用到
        srand()，它的实参就是随机数种子。<br>
        要想随机数种子不断改变，可以用 time() 函数( 头文件 time.h )作为 srand() 的实参，当 time() 的实参为 NULL( 空类型，等价于数字 0 ) 时，即
        time(NULL) 会返回一个时间戳，时间戳是指: 从 1970 年 1 月 1 日 00 : 00 : 00 起，到目前为止经过的秒数，鉴于 int 类型的极限是 2147483647
        ,它会在 2038 年 1 月 19 日 11 : 14 : 17 时到达 int 类型的存储极限，但不必担心，因为到时候 int 的字节数应该会变得更长( 目前是4字节 )。<br>
        例子:
        <code>
          #include&lt;stdio.h&gt;
          #include&lt;stdlib.h&gt;
          #include&lt;time.h&gt;
          int main()
          {
            int i;
            srand((unsigned int)time(NULL));
            for (i = 0; i < 100; i++)
            {
              printf("第 %d 个随机数: %d\n", i + 1, rand() % 100);		//取余可以限定输出随机数的范围
            }
            return 0;
          }
        </code><br>
        以上代码可以产生 100 个 0 ~ 99 的随机数。（ 动动脑筋，利用随机数，可以自己制作个简单的小游戏。 ）<br>
        rand()函数原型: int rand(void);<br>
        srand()函数原型: void srand(unsigned int seed);<br>
      </details>
      <details>
        <summary>定义和使用</summary>
        自定义函数分声明、定义、调用三步,声明一般放在最顶部，定义一般放在主函数的下边。<br>
        <span class="em">声明格式:</span><br>
        数据类型 函数名( 参数列表 );<br>
        数据类型决定的是函数的返回值类型，与参数无关，参数是函数接收的变量类型，声明时写的参数称为形式参数( 形参 )，调用时传入的变量称为实际参数( 实参
        )，形参数量必须等于实参数量。eg: void order( int a,int b ); void是空类型，代表不返回值，每个参数用逗号隔开。<br>
        <span class="em">定义格式:</span><br>
        数据类型 函数名( 参数列表 ) { 代码体; }<br>
        定义时，函数内一般只用到形参和函数内临时声明( 只在函数内有用 )的变量。<br>
        <span class="em">调用格式:</span><br>
        调用时，只要使用函数名并写上实参即可: 函数名( 实参列表 );<br>
        实参的位置、类型与形参是一一对应的,函数执行完后不会改变实参的值，函数只接收实参的值。函数被调用时可以直接当作一个语句被执行( 本质上是相同的 )。
      </details>
      <details>
        <summary>函数类型和返回值</summary>
        从参数上来讲，函数类型分有参函数、无参函数两种，无参函数声明即没有参数的函数，声明时可以在括号内写 void，也可以什么都不写。<br>
        返回值:<br>
        函数的返回值是通过 return 语句设定的，它后面的值可以是数字、字符、变量、表达式，也可以什么都不写只表示函数结束。函数的返回值与函数的类型是相
        同的，如果设定的返回值与函数类型不同，<span class="em">则会将返回值强制转换为与函数相同的类型,如果无法转换( 例如字符串转为整型 ),则会报错。
        </span><br>
        一个函数可以有多个 return 语句，它可以根据情况需要，提前中断函数，实现函数有很多个不同的返回值。
      </details>
      <details>
        <summary>函数的形参、实参、值传递</summary>
        形参:<br>
        形参出现在函数的声明、定义中，在该函数的整个函数体内都可以使用，但离开该函数便不能使用。<br>
        实参:<br>
        实参的作用是给被调函数传递值，它可以是变量、常量、表达式、另一个函数等( 很多 )，实参只传递值给被调函数，被调函数不会改变实参本身的值。<br>
        值传递:<br>
        被调函数在被调用前，形参是不在内存中分配空间的，直到实参传递值给形参才会在内存中分配空间,在被调函数执行完成后，形参的空间又会被释放，所以形参只
        在被调函数执行时占用内存空间。<br>
        "值传递"中形参不会改变实参的值，但"地址传递"中形参可以改变实参的值，这在指针中会讲到。
      </details>
      <details>
        <summary>函数嵌套、递归</summary>
        嵌套:函数的使用是非常灵活的，函数之间可以经常调用，函数之间调用就称为嵌套。<br>
        递归:递归是一种特殊的嵌套，就是函数自己调用自己，这样就可以形成类似于循环的结构，不过递归的使用甚至比循环要更灵活一些，相应的也比循环复杂。由于
        递归在运行时会不停在内存中创造形参，因此它占用的内存资源比较多，虽然灵活，但要谨慎使用。<br>
        若在考试中没有特殊要求，尽量不要使用递归函数。<br>
      </details>
      <details>
        <summary>局部变量、全局变量</summary>
        局部变量:<br>
        局部变量,也称 auto 变量，因为其有另一种声明方式: auto 类型 变量名; 。局部变量是在函数中声明的变量。<br>
        作用域:该函数内，从变量声明到函数结束的部分。<br>
        命名:因为作用域的不同，不同函数内的局部变量名可以重名。<br>
        全局变量:<br>
        全局变量是在函数外声明的变量。<br>
        作用域:整个项目中的所有文件，所有函数。如果要在项目中的另一个文件中使用，要加入引用声明: extern 类型 变量名;<br>
        命名:可以与函数内的局部变量重名，此时全局变量无效，<span class="em">函数会优先使用自身内的局部变量。</span><br>
      </details>
    <h2>九、宏和文件包含</h2>
      <details>
        <summary>无参宏</summary>
        无参数宏，也称为宏常量，如果在程序中要经常用到某个值，为了方便管理，例如圆周率 P，可以将其定义为: #define P 3.1415<br>
        在编译预处理时，会将该宏定义后所有的 P 替换为 3.1415，这个替换的过程称为宏展开，宏定义只在定义的文件中起作用。<br>
        注意:
        <ol>
          <li>宏定义的命名通常大写，与变量区分</li>
          <li>宏定义不是C语言，语句后不写分号</li>
          <li>宏定义可以是常数、表达式</li>
          <li>宏定义在编辑时编译器不作语法检查，只有在编译时进行宏展开才会报错</li>
          <li>在宏定义中可以引用已定义的宏名</li>
          <li>可以用 #undef 命令终止某个宏的作用域</li>
        </ol>
      </details>
      <details>
        <summary>有参宏</summary>
        也称为宏函数，一些短小但经常重复使用的函数可以被写成宏函数，宏函数没有普通函数的参数压栈、跳转、返回等的过程，可以提高程序运行效率。<br>
        格式: #define 宏函数名 ( 参数列表 ) (代码体)<br>
        例如 #define MAX (x , y) ( (a>b)?(a):(b) ) 的作用是返回两个数中较大的一个，可以发现这个定义中用到了很多括号，这是因为宏展开只是做了原
        封不动的替换，因此在运用时可能会因运算符优先级而出现不必要的麻烦，而加上详细的括号就可以避免这些情况。<br>
        宏函数的使用与普通函数没什么区别。<br>
        如果只是用到一两次，就没有必要使用宏函数了，因为这对程序运行效率的提高可以忽略。
      </details>
      <details>
        <summary>文件包含处理</summary>
        文件包含处理，在 C 语言中就是指 #include 指令导入文件内容，它不仅可以导入以 .h 结尾的头文件，还能导入其它文件，例如 .txt 结尾的或 .c 结尾
        的，都可以被导入，理论上它可以导入任何格式的文件。<br>
        #include 指令后，文件名用尖括号 &lt;&gt; 包起来的，代表按照系统默认的文件路径去找到文件。而文件名用双引号 "" 括起来的，代表导入用户自定义的
        文件，系统会先在源文件当前目录下查找该文件，如果找不到才会在系统指定目录( 如果系统有指定 )下查找。<br>
        文件包含类似于宏展开，因此可以在导入的文件中写: extern 类型 函数名 (参数列表); 这样的语句，就可以导入在此项目下其它文件中定义的函数。<br>
      </details>
    <h2 id="ten">十、指针</h2>
      <details>
        <summary>内存地址</summary>
        内存空间被分成很多个字节，每个字节的空间都有其对应的的编号，这个编号就是内存的地址，编号的长度由处理器的位数决定，32位处理器其内存编号的长度就
        是 32 位二进制，相应的 64 位处理器其内存编号是 64 位的二进制，因此不同位数的处理器能支持的最大内存的大小也是不同的。<br>
        内存中运行的每一个数据都会被分配相应的地址，并且其占有的地址数也不同，例如 int 大小为 4 个字节，它占有 4 个地址。<br>
        C 语言中变量的字节大小、地址都可以被求出。<br>
        <span class="em">求大小:</span><br>
        变量的字节大小可以用 sizeof() 运算符来求出。<br>
        sizeof( 变量类型 ) 或 sizeof( 变量名 ) 都可以。<br>
        然后可以用 printf("该变量的大小是: %d",sizeof(变量名)); 输出变量的大小 ( 如果使用的是 MS 的编译器要用占位符 %zd 输出大小 )。<br>
        <span class="em">求地址:</span><br>
        求变量地址要用 “取地址”符号 & ，并且地址是以十六进制表示的，因此输出要用到占位符 %p<br>
        printf("该变量的内存地址是: %p",&变量名);<br>
        以上显示的地址是变量的首个地址，大多数类型是同时占有多个地址的，这些地址是按顺序排列的。<br>
        例子:
        <code>
          #include&lt;stdio.h&gt;
          int main()
          {
            int a = 0;
            char b = 0;
            double c = 0;
            float d = 0;
            printf("\n 整型大小: %zd\n 字符型大小: %zd\n 双精度浮点型大小: %zd\n 单精度浮点型大小: %zd\n", sizeof(a), sizeof(b), sizeof(c), sizeof(d));
            printf(" 变量 a 地址: %p\n 变量 b 地址: %p\n 变量 c 地址: %p\n 变量 d 地址: %p\n",&a,&b,&c,&d);
            return 0;
          }
        </code>
      </details>
      <details>
        <summary>指针变量、指针变量大小</summary>
        内存区的编号就是地址，而地址就是指针，C 语言定义了一个变量类型用来存放指针，指针类型，该类型的变量就是指针变量。<br>
        指针变量定义格式: 类型 *变量名;<br>
        容易看出，只需要声明时在变量名前加上 * 就可以了，各种类型的指针分别指向其对应的数据类型。注意与 * 运算符区别开，* 可以是相乘，也
        可以是"取值"（ 与"取地址相对" ）。通常将指针变量称作"指针"，但实际上它们的含义不一样。<br>
        所有指针变量的大小在同一操作系统下是相同的，32位是 4 个字节，64 位是 8 个字节，这是为了与内存编号的长度相对应。<br>
        指针变量的赋值要用到取地址运算符 "&": 指针变量 a = &被获取地址的变量b;<br>
        语义是: 将变量 b 的地址赋给指针变量 a。<br>
        这样，指针变量 a 与变量 b 就建立了关系，指针变量 a 可通过取值运算符 "*" 改变被取地址的变量 b 的值: *指针变量 a = 值;<br>
        语义是: <span class="em">找到指针变量存储的地址，将值赋给该地址。</span>这样，就间接改变了变量 b 的值。<br>
        以上关系可以用下图表示:<br>
        <img src="../image/指针变量与变量的关系.PNG" alt="指针变量与变量的关系"><br>
        指针类型还分级别，分一级指针、二级指针、三级指针.......，分别用类型 *变量名、类型 **变量名、类型 ***变量名......来声明。
      </details>
      <details>
        <summary>用指针变量作为函数参数</summary>
        调用函数时，实参传递值给形参，函数调用后，形参被销毁，实参值不变，这是值传递。而当指针变量作为形参时（即函数接收的是一个地址），形参就可以改变
        实参的值，这称为地址传递。<br>
        首先形参的类型得是对应的指针类型，然后为函数传递的实参是指针，可以是指针变量的值（*指针变量），也可以用取地址运算符（&变量）。<br>
        地址传递之所以能改变实参的值，是因为函数接收的是变量的地址，直接对变量的地址进行操作。<br>
        例子:
        <code>
          #include &lt;stdio.h&gt;
          void huan(char* x, char* y);                           //声明函数 huan()
          main()
          {
            char a = 'a', b = 'b';				//定义字符变量 a、b
            printf("\n首先:\n a 的地址存放: %c\n b 的地址存放: %c\n", a, b);
            huan(&a, &b);				        //将变量 a、b 的地址传递给函数 huan()
            printf("将字符变量 a、b 的值互换:\n a 的地址存放: %c\n b 的地址存放: %c\n", a, b);
            return 0;
          } 
          void huan(char* x, char* y)                            //定义函数 huan()
          {
            char temp = *x;					//将地址 x 存储的值赋给临时变量 temp，注意地址 x 与 x 的地址的区别
            *x = *y;						//将地址 y 存储的值放到地址 x 中
            *y = temp;						//将 temp 的值放到地址 y 中
          }
        </code><br>
        函数 huan() 接收到变量 a、b 的地址，指针变量（形参） x、y 被赋值，然后对 x、y 进行取值操作，即对 x、y 指向的地址进行操作。
      </details>
      <details>
        <summary>向函数传递数组</summary>
        数组名其实就是数组首元素的地址，是一个常量，定义一个数组 arr[] ,可以用以下代码验证:<br>
        printf(" 数组名 %p == 数组首元素的地址 %p ", arr, &arr[0] );
        当向一个函数传递数组时，因为数组名是地址，所以接收数组的形参要定义成指针类型，其次一般还要额外加一个形参指出数组的长度，不加也可以，但不是
        规范的写法。<br>
        下面实现一个冒泡排序的函数:
        <code>
          #include&lt;stdio.h&gt;
          int arr[100], i, i4;                                                          //定义数组 arr[]、数组长度 i、循环打印变量 i4
          void order(int* x, int y);                                                    //定义排序函数 order()
          int main()
          {
            printf("请输入一列数列，每个数字前加一个空格( 包括第一个 ): ");
            for (i = 0; (getchar() != '\n'); i++) { scanf_s("%d", &arr[i]); }            //获取数组
            order(arr, i);                                                                //将数组排序
            printf("排序后数组: ");
            for (i4 = 0; i4 &lt; i ; i4++) { printf("%d &lt;= ",arr[i4]); }                     //输出数组
            printf("\n");
            return 0;
          }
          void order(int* x, int y)                                                       //定义排序函数 order()
          {
            int i2, i3, temp;                                                              //定义循环变量i2、i3、临时变量 temp
            for (i2 = 0; i2 < y - 1; i2++)                                                 //循环遍历 y - 1 次
            {
              for (i3 = 0; i3 < y - 1 - i2; i3++)                                          //遍历一次交换 y - 1 - i2 次
              {
                if (x[i3] > x[i3 + 1])
                {
                  temp = x[i3 + 1];
                  x[i3+1] = x[i3];
                  x[i3] = temp;
                }                                                                           //进行一次交换
              }
            }
          }
        </code><br>
        以上代码首先用 for 接收一个数组并读出数组的长度i，然后定义函数 order() 对数组进行排序，之后再用 for 输出数组。<br>
        对于 order() 函数，它接收到数组的地址和数组的长度 i，然后直接对地址进行操作（地址相同，相当于用不同的名字对同一个数组进行操作），对数组进行
        冒泡排序。
      </details>
      <details>
        <summary>指针与数组</summary>
        前面说过数组名是一个地址常量，而地址又是指针变量所储存的值，看起来它们是有共通之处的，事实上，可以通过指针变量来对数组进行操作:
        <code>
          #include&lt;stdio.h&gt;
          int arr[10] = { 2 , 5 , 12 };
          int* p;
          int main()
          {
            p = arr;                              //数组名本身就是地址，因此不需要取地址符
            printf("%d = %d\n", p[2] , arr[2]);
            return 0;
          }
        </code><br>
        要注意的是，指针变量和数组名还是有本质上的区别的，前者是变量，后者是常量。<br>
        指针还可以对数组进行更多操作:<br>
        <span class="em">指针加减法运算:</span><br>
        首先思考 *(arr + 1) 代表的是什么? 代表的是第二个数组元素的值，其等价于 *(p + 1),这两个可以概括为一个式子: *(地址 + 偏移量)<br>
        以上称为指针加法运算，要注意其并不是简单的整数相加。一单位的偏移量代表的是一个数据类型( 或数组类型 )的长度,例如 *(p + 1) 对 int* 来说是加
        了一个 int(4字节) 的长度，而对 char* 的指针变量来说是加了一个 char(1字节) 的长度。<br>
        所以还可以这样打印数组: for(i=0 ; i < 10 ; i++) { printf("%d ",*(p + i)); }<br>
        总结下来就是: 地址 +(或 -) 偏移量 == 另一个地址<br>
        很容易看出，若是两个指针相减，得到的就是该指针类型的偏移量。
      </details>
      <details>
        <summary>指针数组</summary>
        指针数组，即每个元素的类型都是指针类型的数组。<br>
        声明格式: 类型* arr[元素数] = { &a, &b, &c...... };<br>
        例子:
        <code>
          include&lt;stdio.h&gt;
          int a = 1, b = 2, c = 3;
          int* arr[3] = { &a, &b, &c };
          int main()
          {
            printf("a = %d , b = %d , c = %d\n",*arr[0],*arr[1],*arr[2]+1);
            return 0;
          }
        </code><br>
        输出结果是: a = 1 , b = 2 , c = 4
      </details>
      <details>
        <summary>多级指针</summary>
        指针变量存放的是变量的地址，指针变量本身也是变量，也有地址，二级指针存放的就是一级指针的地址，三级指针存放二级指针的地址......依此类推。<br>
        指针的层级关系就像指针与变量一样，只是叫法不同而已，每次取值( * )都是降一级，<br>
        多级指针声明格式: 类型***** 指针变量名; 星号的数量代表了级别。
      </details>
    <h2>十一、结构体和共用体</h2>
      结构体是计算机二级考试的必考难点，共用体一般占两分。
      <details>
        <summary>typedef——为数据类型起别名</summary>
        有时候类型名过长写起来不方便，例如 unsigned long long a = 10; 这样一个声明，写起来略有费事，且影响代码整洁度，为此，可以使用 typedef 为
        一个数据类型起一个短点的名字。例如:<br>
        typedef unsigned long long unl;<br>
        这样，就可以用 unl 来代替 unsigned long long 这个长名字，要注意区别，typedef 只是为数据类型更换名字，并不是创建新的数据类型。<br>
        定义了新名字，就可以使用简短的名字来进行声明，如: unl a;
      </details>
      <details>
        <summary>结构体的定义</summary>
        每一个数组的类型都是固定的，如果要打印一个拥有不同数据类型的表格，就需要多个数组的复杂配合，为了可以更加灵活运用和方便管理，便诞生了结构体，而
        结构体下的每一个结构体变量，就相当于一个可以包含不同类型数据的数组。<br>
        <span class="em">声明:</span><br>
        结构体声明分两部分，结构体声明、结构体变量声明:
        <code>
          struct 结构体名{ 数据类型 变量名; 数据类型 变量名; ...... 数据类型 变量名; };        //结构体声明
          struct 结构体名 结构体变量名 = { 数据 , 数据 , ... , 数据 }                           //结构体变量声明
        </code><br>
        结构体声明确定的是结构体的名称、结构体变量包含的数据类型和赋值顺序，结构体变量声明的作用是确定结构体变量的名称、对该变量下的各变量进行依次赋值，
        是的，就是按结构体声明时确定的变量顺序进行依次初始赋值。<br>
        一个结构体可以有多个结构体变量，一次也可以声明多个结构体变量，只需要用逗号隔开各结构体变量即可。如:<br>
        struct 结构体名 结构体变量名 = { 数据 , 数据 , ... , 数据 } , 结构体变量名 = { 数据 , 数据 , ... , 数据 };<br>
        结构体变量也可以只声明，不赋值。
      </details>
      <details>
          <summary>结构体变量的使用</summary>
          表示结构体变量的某一个变量用符号"." ,格式: 结构体变量名.变量名<br>
          例如，声明后修改某一项的值: 结构体变量名.变量名 = 值;<br>
          但如果是要修改数组里的字符串就要用到一个封装好的函数 strcpy() 了，函数在 string.h 这个头文件里。用法:<br>
          strcpy( 结构体名.数组名 , 字符串 );<br>
          如果是 MS 的编译器，格式为 strcpy_s( 结构体名.数组名 , 字符串长度 , 字符串 );<br>
          <span class="em">结构体变量本身也可以是数组:</span><br>
          结构体数组就相当于多个结构体变量，所以可以用于将多个同一类的结构体变量统一起来，声明格式:
          <code>
          struct 结构体名 结构体数组名[结构体变量个数] = {
            { 数据，数据，数据 ... ，数据 },
            { 数据，数据，数据 ... ，数据 },
            { 数据，数据，数据 ... ，数据 },
            ......,
            { 数据，数据，数据 ... ，数据 }
          };
          </code><br>
          结构体的使用很灵活，它可以非常庞大，例如定义多个结构体数组，每个结构体数组元素里再使用多个二维数组。<br>
          下面是各种结构的例子:
          <code>
            include&lt;stdio.h&gt;
            include&lt;string.h&gt;
            //用一个结构体变量表示一个人的信息
            struct xinxi { long long bh; char name[31]; char xb[3]; char addr[41]; };	//每一行代表一类信息
            struct xinxi
            xm = { 201707020129,"小明","男", "陕西省 西安市 鄂邑" },
            xw = { 201707020106 ,"小王" ,"男","陕西省 榆林市 神木县" },
            xmn = { 201707020103 ,"小美" ,"女","北京市 朝阳区" };
            //定义表格,用逗号分隔每一个结构体变量
            int main()
            {
              strcpy_s(xm.name,6,"小明3");                      //用 strcpy 改变了其中一个字符串
              printf("\n 学号: %lld\n 姓名: %s\n 性别: %s\n 居住地: %s\n\n ", xm.bh, xm.name, xm.xb, xm.addr);
              printf("\n 学号: %lld\n 姓名: %s\n 性别: %s\n 居住地: %s\n\n ", xw.bh, xw.name, xw.xb, xw.addr);
              printf("\n 学号: %lld\n 姓名: %s\n 性别: %s\n 居住地: %s\n\n ", xmn.bh, xmn.name, xmn.xb, xmn.addr);
              return 0;
            }
          </code><hr>
          <code>
            include&lt;stdio.h&gt;
            //用一个含二维数组的结构体变量，表示很多人的信息
            struct xinxi { long long bh[3][12]; char name[3][5]; char xb[3][3]; char addr[3][31]; };
            //第一个是整型，其也可以用一维数组存储，但为了结构直白，用了二维数组。二维数组的每一行代表一个人的信息
            struct xinxi
            bg = {
              { { 201707020129 },{ 201707020106 },{ 201707020103 } },
              { { "小明" },{ "小王" },{ "小美" } },
              { { "男" },{ "男" },{ "女" } },
              { { "陕西省 西安市 鄂邑" },{ "陕西省 榆林市 神木县" },{ "北京市 朝阳区" } }
            };
            //定义表格,用逗号分隔每一个二维数组
            int main()
            {
              int i, i2;
              for (i = 0, i2 = 0; i < 3; i++, i2++)
              {
                printf("\n 学号: %lld\n 姓名: %s\n 性别: %s\n 居住地: %s\n\n ", bg.bh[i][0], bg.name[i], bg.xb[i], bg.addr[i]);
              }	//打印整型数组元素时，要写明数组元素的行号与编号，而打印字符串时，只需写明位于第几行就可以了
              return 0;
            }
          </code><hr>
          <code>
            include&lt;stdio.h&gt;
            //用一个结构体数组表示很多人的信息
            struct xinxi { long long bh; char name[21]; char xb[3];char addr[51]; };
            struct xinxi bg[3] = {
              { 201707020129,"小明","男", "陕西省 西安市 鄂邑" },
              { 201707020106 ,"小王" ,"男","陕西省 榆林市 神木县" },
              { 201707020103 ,"小美" ,"女","北京市 朝阳区" }
            };
            int main()
            {
              int i, i2;
              for (i = 0, i2 = 0; i < 3; i++, i2++)
              {
                printf("\n 学号: %lld\n 姓名: %s\n 性别: %s\n 居住地: %s\n\n ", bg[i].bh, bg[i].name, bg[i].xb, bg[i].addr);
              }
              return 0;
            }
          </code><br>
          相比于用二维数组，用结构体数组更加方便直观。当遇到层级关系较多的情况，可以将结构体数组和二维数组结合起来使用，二者并不冲突。
      </details>
      <details>
        <summary>对结构体数组排序</summary>
        结构体就像一个表格，既然有表格，那就有排序，下面是根据结构体变量里的某一项数据进行排序:
        <code>
          include&lt;stdio.h&gt;
          //对结构体数组排序
          struct xinxi { long long bh; char name[21]; char xb[3];char addr[51]; };
          struct xinxi bg[3] = {
            { 201707020129,"小明","男", "陕西省 西安市 鄂邑" },
            { 201707020106 ,"小王" ,"男","陕西省 榆林市 神木县" },
            { 201707020103 ,"小美" ,"女","北京市 朝阳区" }
          };
          void order();							//声明排序函数 order()
          int i, i2;					         	//循环变量i，i2
          int main()
          {
            printf("根据学号排序，请依次输入学号，用空格分隔: ");
            for (i = 0; i < 3; i++) { scanf_s("%lld", &bg[i].bh); };    //获取学号
            order();							//排序
            for (i = 0, i2 = 0; i < 3; i++, i2++)
            {
              printf("\n 学号: %lld\t 姓名: %s\t 性别: %s\t 居住地: %s\n ", bg[i].bh, bg[i].name, bg[i].xb, bg[i].addr);
            }
            return 0;
          }

          void order()							//定义排序函数 order()
          {
            struct xinxi ls;						//用于临时存储的结构体变量 ls
            for (i = 0; i < 2; i++)					//共遍历 2 次
            {
              for (i2 = 0; i2 < 2 - i; i2++)		        	//每次遍历交换 2 - i 次
              {
                if (bg[i2].bh > bg[i2 + 1].bh)	                 	//比较学号的大小
                {
                  ls = bg[i2 + 1];			         	//存储 bg[i+1] 的所有值到 ls 上
                  bg[i2 + 1] = bg[i2];	                		//将 bg[i] 的值转到 bg[i+1] 上
                  bg[i2] = ls;				    	       	//将 bg[i+1] 的值转到 bg[i] 上
                }					    	         //完成一次交换
              }
            }
          }
          //要注意比较的是学号，但交换的是整个结构体变量。/t 表示制表符，相当于 8 个空格。
        </code>
      </details>
      <details>
        <summary>结构体嵌套</summary>
        结构体嵌套是工作中常用的东西，尤其是游戏中，结构体中只能嵌套另一结构体的结构体变量，嵌套的方式就是在结构体声明中再声明结构体变量，格式:<br>
        strcut 结构体名{ strcut 结构体名 结构体变量名;数据类型 变量名; 数据类型 变量名; ... 数据类型 变量名; }<br>
        例子:
        <code>
          include&lt;stdio.h&gt;
          //结构体嵌套
          struct skills { char call[21]; long pain; long width; };
          struct persons { char name[21]; long HP; long MP; long gj; struct skills skill[4]; };   //嵌套了结构体数组 skill[4]
          struct persons ms = { "盲僧",525,200,87,{ { "天音击", 125, 800 },{ "金钟罩/铁布衫",0,300 },{ "分筋错骨/天雷击",100,400 }
                                                    ,{ "猛龙摆尾",625,100 } } };
          int i;
          int main()
          {
            printf("\n 人物: %s\t血量: %d\t能量: %d\t攻击力: %d\n 技能:\n ",ms.name,ms.HP,ms.MP,ms.gj);
            for (i = 0; i < 4; i++) { printf("\n      名称 : %s          伤害 : %d            范围 : %d"
                                               , ms.skill[i].call, ms.skill[i].pain, ms.skill[i].width); }  //注意这里的参数
            printf("\n\n ");
            return 0;
          }
        </code><br>
        注意:<br>
        <ol>
          <li>被嵌套的结构体必须提前声明。</li>
          <li>声明时只能在结构体中嵌套另一个结构体的结构体变量。</li>
          <li>有嵌套的结构体的结构体变量在按顺序赋值时会进入其内嵌的结构体变量内进行赋值，并且要将内嵌的结构体变量的值整体用大括号括住。</li>
          <li>使用内嵌的结构体的值时，就像路劲一样，要依次进入其上层的结构体变量内。</li>
        </ol>
      </details>
      <details>
        <summary>共用体（联合体）</summary>
        共用体无论是考试还是开发，用的都很少。<br>
        共用体定义好其中的变量类型后就相当于一类通用类型的变量，其所占内存空间长度等于其内占空间最大的类型的长度，共用体的声明和使用与结构体相同。<br>
        共用体变量的值是其最后一次存放的值。<br>
        例子:
        <code>
          include&lt;stdio.h&gt;
          //共用体的使用
          union lei { int a; char b; float c; double d; };
          union lei e;
          int main()
          {
            e.a = 1;
            e.b = 'f';
            e.c = 3.14;
            e.d = 6.28;
            printf("\n 整型: %d\n 字符型: %c\n 单精度浮点: %.2f\n 双精度浮点: %.2lf\n\n ",e.a, e.b, e.c, e.d);
            return 0;
          }
        </code><br>
        该共用体所占内存的长度是 double 的长度，也就是 8 字节，其值是最后一次赋的值，也就是 6.28，前面的值都被覆盖掉了，只会输出乱码。
      </details>
      <details>
        <summary>链表基本介绍</summary>
        
      </details>
    <h2>十二、位操作</h2>
      <details>
        <summary>进制转换</summary>
        进制转换大致分三类，其它进制转十进制、二进制转其它进制、十进制转二进制。这里的其它基本指八进制和十六进制。<br>
        <span class="em">其它进制转十进制:</span><br>
        用权值法，具体就是，从进制位的末尾开始，依次乘以该进制的 n 次幂（从 0 开始），然后相加即可。例如:<br>
        十六进制数 2C 转十进制,就是 2 x 16<sup>1</sup> + C x 16<sup>0</sup> = 44 ,十六进制里，10 ~ 15 用 A ~ F 表示。<br>
        <span class="em">二进制转其它进制:</span><br>
        八进制和十六进制于二进制的互换很简单，只要从末尾开始，每三位二进制等于一位八进制，每四位二进制等于一位十六进制，例如:<br>
        二进制数 10011101 分别转八进制和十六进制,首先转八进制，将其变为 010 011 101，所以依次是三个八进制数字 2 3 5,所以就是八进制数 235。接下
        来如法炮制为十六进制数 1001 1101，依次转为十六进制数 9 D，所以就是十六进制数 9D。<br>
        <span class="em">十进制转二进制:</span><br>
        用除二取余逆序法，就是用短除法，每次除 2，若为技术取出余数 1，再除 2，直到值为 1 或 0，然后从下往上读。具体可用下图表示:<br>
        <img src="../image/除二取余逆序法.PNG" alt="除二取余逆序法"><br>
        不过这只适用于整数部分的转换，此外，小数部分的十进制转换要用另一种方法，。

        上述方法是用于笔试的时候，如果是上机考试，可直接用计算机自带的计算器（计算器有一个程序员模式）来实现进制转换，简单、准确。
      </details>
      <details>
        <summary>计算机存储数据的基本方式</summary>
        内存中最小的存储单元是字节，用 Byte 表示，而一字节内有八个二进制，每一位二进制称为一位，用 bit 表示。<br>
        一个变量内存储的二进制数没有占满它的全部位时，前面的位会自动用 0 补全。<br>
        计算机对二进制数有三种处理形式: 补码、反码、源码<br>
        补码: 是计算机存储数据的一般形式，补码就是对原二进制全部进行按位取反即可。<br>
        反码: 在补码的基础上减一。<br>
        源码: 保证反码的首位不变，再对其它位进行按位取反。<br>
        对于有符号类型，即分正负数，二进制的最高位为符号位，0 表示正，1 表示负。因此，拿到一段计算机中存储的二进制时要先进行转换。<br>
      </details>
      <details>
        <summary>位运算符和位移运算符</summary>
        位运算符和位移运算符共包括 6 个: ~、>>、<<、&、^、| ,除左移和右移优先级相同外，优先级依次从高到低。<br>
        <span class="em">按位取反运算符 ~ :</span>很简单，将一段二进制的补码的每一位数字按位取反，即 0 变 1 或 1 变 0。<br>
        <span class="em">按位 与 运算符 & :</span>对两段二进制码的对应位进行比较，当对应位都是 1 时取 1，否则取 0，产生一段新二进制码。<br>
        <span class="em">按位 或 运算符 | :</span>对两段二进制码的对应位进行比较，当对应位都是 0 时才取 0，产生一段新二进制码。<br>
        <span class="em">按位 异或 运算符 ^ :</span>对两段二进制码的对应位进行比较，当对应位相同时为 0，不同时为 1，产生一段新二进制码。<br>
        <span class="em">左移运算符 << :</span>格式是 数字1 << 数字2，含义是将 数字1 的二进制码每位向左移 数字2 个位，空出的位用0补齐。<br>
        <span class="em">左移运算符 >> :</span>格式是 数字1 >> 数字2，含义是将 数字1 的二进制码每位向右移 数字2 个位，空出的位用0补齐。<br>
        需要说明的是，除按位取反运算符外，其它的都不是在计算机任何存储形式的二进制码上运算的，而是在原始二进制码的形式上进行运算的。<br>
        例子:<br>
        ~ :
        假设是一字节，即字符型，20 的二进制码为 10100，首先补全为 0001 0100<br>
        补码 1110 1011， 反码 1110 1010， 源码 1001 0101<br>
        计算后的数字就是源码的值，-21。<br>
        & :
        仍然假设是一字节，即字符型，20 和 30 的二进制码分别为 10100、11110，首先补全为 0001 0100、0001 1110<br>
        计算后的新值:0001 0100，换成十进制: 20<br>
        |、^ 和 & 的计算步骤一样。<br>
        位移运算符每次移动的位数相当于给原数乘或除 2 的对应次幂。例如 1 左移两位为 4 ，相当于乘 2 的 2 次幂。而 4 右移两位为 1，相当于除 2 的 2
        次幂。即左乘右除。
      </details>
      <details>
        <summary>位运算的应用</summary>
        1、位移运算符提供了一种简便的 2 的任意次幂的运算方式。<br>
        2、打开、关闭、转置位，这个考试不考，工作中会用。<br>
        3、交换两个变量的值而不需要临时变量:<br>
        <code>
          //交换 a、b 的值
          a = a ^ b;
          b = a ^ b;
          a = a ^ b;
        </code><br>
        暂时不用纠结为什么，只需要记住格式就好。
      </details>
    <h2>十三、文件操作</h2>
      <details>
        <summary>文件指针</summary>

      </details>
  </div>
</body>

</html>