#include<stdio.h>
#include<math.h>
//d = y - x，y 是 x 的下一个素数，二者是相邻素数，现在假设有无数对 x、y，且其对应的 d 为 2，求指定范围内有多少对这样的 x、y
int main()
{
	int n, nums[30000] = { 0 }, i, j, k, temp, x;
	//范围 n、素数列 nums、循环变量 i 和 j、计算满足条件的 k、临时变量 temp、数组编号 x
	scanf("%d", &n);		nums[0] = 2;
	for (x = 0, i = 3; i <= n; i++)						//求出 n 内所有素数
	{
		for (j = 0, k = 1, temp = (int)sqrt(i) + 1; nums[j] < temp; j++)	//判断 i 是否是素数
			if (i%nums[j] == 0)
			{
				k = 0;									//标记状态，i 不是素数
				break;									//不是素数，跳出
			}
		if (k == 0)		continue;						//未循环到数组末尾便跳出或到末尾，不是素数，跳过此次循环
		nums[++x] = i;									//赋值素数到 nums
	}
	for (i = k = 0; nums[i] != 0; i++)
		if (nums[i + 1] - nums[i] == 2)		k++;		//二者是相邻且差值为 2 的素数对，满足条件
	printf("%d", k);
	return 0;
}
/*
思路：
利用埃氏筛法快速找出 n 以内所有素数并存到数组中，对数组的相邻元素比较，差值为 2 则 k 自增一次。
埃氏筛法实现：for 中先为 nums[0] 赋初值为 2，循环变量 i 从 3 一直自增到大于 n。循环中判断 i 是否是素数，若是则赋值到 nums，否则
不赋值。判断方法是内嵌一个 for 遍历 nums，只要 nums[j] < (int)sqrt(i) + 1 便不终止，过程中用 i % nums[j] 判断是否能整除，
若能则不是素数，标记变量 k 为 0，k 为 0 则跳过该 i 不赋值到 nums 中。
注意：
1. 求素数时，不必循环取余到 i，只需取余到 (int)sqrt(n) + 1 便可以判定是否为素数，这可大幅减少运算量。
2. 注意循环初值。
3. 此题有多种求法，在我博客的 “随笔” 一栏里能找到我列出的三种求法。
*/

/*
原题：
1007 素数对猜想（20 分）
让我们定义 d(n) 为：d(n) = p(n+1) - p(n)，其中 p(i) 是第 i 个素数。显然有 d(1) = 1，且对于 n > 1 有 d(n) 是偶数。“素数对
猜想”认为“存在无穷多对相邻且差为 2 的素数”。
现给定任意正整数 N(<10 的 5 次方)，请计算不超过 N 的满足猜想的素数对的个数。

输入格式:
输入在一行给出正整数N。

输出格式:
在一行中输出不超过N的满足猜想的素数对的个数。

输入样例:
20
输出样例:
4
*/