#include<stdio.h>
//将一个长为 N 的数组所有元素右移 M 位，最后 M 位移到前 M 位
#define H(x,y,z) (x + y) == (2 * x + z)						//条件结束宏
void huan(int *x,int * y);									//交换两变量一次

int main()
{
	int n, m, i, j, nums[101];								//长度 N、右移位数 m、逆置变量 i 和 j
	scanf("%d%d", &n, &m);
	if (m >= n)	m %= n;										//当 m > n 时，取余
	for (i = 0; i < n; i++)		scanf("%d", &nums[i]);
	if (m != 0)
	{
		for (i = 0, j = n - m - 1; 1; i++, j--)				//逆置左边
		{
			huan(&nums[i], &nums[j]);
			if (H(i, j, 1) || H(i, j, 2) || i == j)	break;	//结束条件
		}
		for (i = n - m, j = n - 1; 1; i++, j--)				//逆置右边
		{
			huan(&nums[i], &nums[j]);
			if (H(i, j, 1) || H(i, j, 2) || i == j)	break;	//结束条件
		}
		for (i = 0, j = n - 1; 1; i++, j--)					//逆置全部
		{
			huan(&nums[i], &nums[j]);
			if (H(i, j, 1) || H(i, j, 2) || i == j)	break;	//结束条件
		}
	}
	for (i = 0; i < n - 1; i++)		printf("%d ", nums[i]);
	printf("%d", nums[i]);
	return 0;
}
void huan(int *x, int * y)									//交换两变量一次
{
	int z = *x;
	*x = *y;
	*y = z;
}
/*
思路：
题目并没有说 M 一定小于 N，而每右移 N 位与未移动没有区别，因此当 M >= N 时，要先进行取余，即 m = n % m。
可以将数组看成左右两部分，即前 N - M 位和最后 M 位，将这两部分各自逆置一次。再将整个数组逆置一次，便实现了右移 M 位。
逆置：将该部分第一位与最后一位交换，接着是第二位与倒数第二位，依次类推，这里用两个变量分别表示前面、后面的数组编号。数组长度有两种情况，
奇数、偶数，因此结束条件有两钟，奇数时为 i + j = 2*i + 2，偶数时是 i + j == 2*i + 1，当满足这两个任意一个，结束交换。
注意：
1. 当 m % n == 0 时，不需要进行移动，因此直接在整个过程上加个条件判断 if(m!=0)
2. 逆置左边时，当 m = n - 1 便会出现 i = j = 0 的情况，这会造成接下来数组越界，因此要在结束条件上加上 i == j
*/

/*
原题：
一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（ A(0)A(1) ...
A(N-1) ) 变换为 ( A(N-M) ... A(N-1)A(0)A(1) ... A(N-M-1) )（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数
据的次数尽量少，要如何设计移动的方法？

输入格式:
每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。

输出格式:
在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。

输入样例:
6 2
1 2 3 4 5 6
输出样例:
5 6 1 2 3 4
*/