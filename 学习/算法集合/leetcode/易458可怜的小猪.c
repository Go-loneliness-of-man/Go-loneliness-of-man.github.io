#include<stdio.h>
#include<stdlib.h>
/*
原题：
有1000只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在15分钟内死去。

问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？

回答这个问题，并为下列的进阶问题编写一个通用算法。

进阶:

假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出“有毒”水桶？n只水桶里有且仅有一只有毒的桶。
*/

int poorPigs(int buckets, int minutesToDie, int minutesToTest)	//桶、最小死亡时间、最小找出时间
{
	int h = minutesToTest / minutesToDie, size, num;			//确定进制 h、编号长度 size、用于计算的 num
	for (size = 0, num = 1; buckets > num - 1; size++)			//确定长度，编号长度即猪的数量
		num *= (h + 1);
	return size;
}

int main()
{
	printf("%d", poorPigs(1000, 15, 60));
	return 0;
}
/*
思路：
在一小时内最多可以测 5 次水，可以得出 5 种结果（0、1、2、3、4），所以用 5 进制编号对水桶进行标记，通过计算可得出标记 1000 桶水必须要
5 位的 5 进制数字。找的方法是，第一次，五只猪在五个位置全喝 0，有毒那瓶编号为 0 的位置就全被喝了，五只猪哪只死了就证明有毒编号对应位置
是 0，第二次如法炮制，最后便得出有毒药水的编号。
核心问题是两个，“可以用几进制的编号”、“该编号要多少位才能标记所有的桶？”只要能表示就绝对可以找出来。拿 5 进制举例，不同长度的 5 进制最
大能表示多少？是 4 乘以 5 的对应次方之和，例如从第一位开始 4 乘 5 的 0 次方 + 4 乘 5 的 1 次方 + 4 乘 5 的 2 次方 .....，则 4
位 5 进制最大表示 624，5 位 5 进制最大表示 3124，所以 1000 的答案就是 5。
简化上面的计算公式是 4乘（5的等比数列前 n 项和） > 水桶数 - 1（由于编号可以全是 0，所以水桶数要 - 1），求 n。进一步求前 n 项和最终得
出 5 的 n 次方 > 水桶数
*/