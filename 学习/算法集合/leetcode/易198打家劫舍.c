#include<stdio.h>
#include<stdlib.h>
/*
原题：
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。
示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。
*/

int rob(int *nums, int numsSize)
{
	if (numsSize == 0)	return 0;						//不必选择的情况
	else if (numsSize == 1)	return nums[0];
	int s[1000], i;
	s[0] = nums[0];										//先确定 s 的前两个元素
	if (s[0] > nums[1])	s[1] = s[0];
	else	s[1] = nums[1];
	for (i = 2; i < numsSize; i++)
		if (s[i - 1] > (s[i - 2] + nums[i]))			//f(n-1) > f(n-2)
			s[i] = s[i - 1];
		else	s[i] = s[i - 2] + nums[i];				//f(n-1) < f(n-2)
	return s[i - 1];
}

int main()
{
	int a[1000] = { 2,1,1,2,123456789 }, len;
	for (len = 0; a[len] != 123456789; len++);
	printf("%d", rob(a, len));
	return 0;
}
/*
思路：
这题类似于前面走楼梯那个，也是用动态规划解决。
首先简化问题：n 个数，计算其中不相邻数字的最大和。
由于两个加数不相邻，则可以得出：

n 个数中的最大和 = n - 1 个数中的最大和

或

n 个数中的最大和 = n - 2 个数中的最大和 + 第 n 个数

设 n 个数最大和为 f(n)，则 f(n) = f(n-1) 或 f(n-2)，结果取决于 f(n-1) 和 f(n-2) 谁大。
基于以上结论，根据数组的前两个元素，就可以依次向后推出由各个 f(n) 组成的数列 s(n)，例如数组：nums[5] = { 2, 1, 1, 5, 3}; 则：
f(n-1) 不存在，f(n-2) = nums[0] = 2，s(1) = f(n-2) = 2
f(n-1) = 2 > f(n-2) = nums[0] = 1，s(2) = f(n-1) = 2
f(n-1) = 2 < f(n-2) = 2 + nums[2] = 3，s(3) = f(n-2) = 3
f(n-1) = 3 < f(n-2) = 2 + nums[3] = 7，s(4) = f(n-2) = 7
f(n-1) = 7 > f(n-2) = 3 + nums[4] = 6，s(5) = f(n-1) = 7
所以 f(5) = 7
所以核心问题就是 f(n) 的实现：f(n-1) = s(n-1)，f(n-2) = s(n-2) + nums[n]（原本数组的下标应该是要减一的，但当 s(n) 也是数组时
便不用这样了）
*/