#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
/*
原题：
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true
*/

#define F(x,y,p,q) ((x == y) && (p != q))
#define T(x,y,p,q) ((x == y) && (p == q))

bool isValid(char* s)
{
	char od[5000] = { '\0' };		int i;
	for (i = 0; *s != '\0'; s++)											//判断字符串
		if (*s == '(' || *s == '[' || *s == '{')	od[i++] = *s;			//按顺序存储符号
		else if (i != 0)													//存在当前符号，进行比较
		{
			if (F(*s, ')', od[i - 1], '(') || F(*s, ']', od[i - 1], '[') || F(*s, '}', od[i - 1], '{'))
				return false;												//与当前字符不对应，返回 false
			else if (T(*s, ')', od[i - 1], '(') || T(*s, ']', od[i - 1], '[') || T(*s, '}', od[i - 1], '{'))
				i--;														//符号对应，向前退一位
		}
		else if (i == 0 && (*s == ')' || *s == ']' || *s == '}'))			//不存在当前符号，返回 false
			return false;
	if (i == 0)		return true;
	else	return false;
}

int main()
{
	char a[200] = "[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([(";
	printf("%d", isValid(a));
	return 0;
}

/*
思路：
只要出现 ( 下一个就必须是 )，而且如果是两个 ( ，那么接下来就必须是两个 )，其它两个也一样。所以，只要按着这个思路来就可以了。
根据这个思路，在读的同时将遇到的所有 (、[、{ 按照顺序都存到数组中，则排在最后的符号表示当前符号，如果下一个闭合符号与当前符号不对应，便
返回 flase，如果是对应的闭合符号，便在数组中向前退一位，若能够一直循环到结束，便返回 true。
注意：
1. 当不存在当前符号时，若遇到闭合符号，便返回 false
2. 若循环结束后，循环变量未退回到 0，代表并不是所有符号都闭合，同样返回 false
*/