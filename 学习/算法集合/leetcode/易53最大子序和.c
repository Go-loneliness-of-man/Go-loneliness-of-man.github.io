#include<stdio.h>
#include<stdlib.h>
/*
原题：
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
*/
//该题有多种解法，下面一一列出，最简单的当然还是暴力破解

/*
//暴力破解
int maxSubArray(int *nums, int numsSize)
{
	int len, *left, sum, max = nums[0], i, j;						//区间长度、左端点、和、左端点位置、循环变量 j
	for (len = 0, left = nums; len < numsSize; left = nums, len++)	//确定待测区间长度，循环
		for (i = 0; i + len < numsSize; left++, i++)				//同一长度下，遍历所有区间
			for (sum = j = 0; j <= len; j++)						//计算一个区间的和
				if ((sum += left[j]) > max)		max = sum;			//更新最大值
	return max;
}
/*
思路：
计算所有组合，输出最大的一个即可。
计算所有组合：计算所有长度下所有区间的和，保存最大值。例如长度为 2 的区间的和，累加到左端的 + 1 的位置便算完了该区间，继续将左端点移到
下一位计算下一个区间，直到左端点位置加当前区间长度超过数组总长度时跳出，进行下一长度下的计算。
暴力破解效率太低，该方法在 leetcode 上提交显示运行超时。
*/


//卡耐基梅隆大学的 Jay Kadane 教授发明了一个线性时间的算法解决该问题，称为 Kadane 算法。
int maxSubArray(int *nums, int numsSize)
{
	int i, sum, max;
	for (i = sum = 0, max = nums[i]; i < numsSize; i++)
	{
		sum += nums[i];								//求和
		if (max < sum)		max = sum;				//判断是否更新最大前缀
		if (sum < 0)	sum = 0;					//检测是否进行切割
	}
	return max;
}
/*
思路：我看了很多博文后勉强算是理解了 kadane 算法，网上那些博文的语言大多非常晦涩（估计是刚开始就翻译的很垃圾大家又都直接复制粘贴），而
且还有很多滥竽充数者，看了反而误导人浪费时间，下面我用较为易懂的语言重新描述一遍。

首先，要理解 Kadane 算法，分两个结论。

1. 对于数组 array[...n]，假设 array[i...j] 就是最大子串（长度大于 1），则对于任意 k(i <= k < j)，有 array[i...k] 的区间
和大于 0。因为只要存在 k 使得 array[i...k] 的区间和小于 0。就有 array[k+1...j] 的区间和大于 array[i...j]，这与开始假设的
array[i...j] 就是 array 的最大子串相矛盾。

2. 假设将数组从左到右切割为若干子串，使得除最后一个子串外，其余子串的各元素之和小于 0（当全正、全负时可能会引起质疑，其实全正时前面子串
都为空即可，全负时最后子串为空即可），则对于所有子串 array[i...j]、k（i <= k < j）存在 array[i...k] 的区间和大于 0，此时，满足
条件的最大子串只能是上面某个子串的前缀，而不可能跨越多个子串。

现在证明，假设 array[p...q]。是 array 的最大子串，而 array[p...q] 跨越了 array[i...j]，array[j+1...k]。根据第二
个结论的分组方式，存在 i <= m < j 使得 array[i...m] 的区间和是 array[i...j] 中所有区间的最大值，存在 j+1 <= n < k 使得
array[j+1...n] 的区间和是 array[j+1...k] 中所有区间的最大值。因为 array[m+1...j] 使得 array[i...j] 的和小于 0，比較
array[i...m] 和 array[j+1...n]，假设 array[i...m] 的和大于 array[j+1...n]，则 array[i...m] > array[p...q]（这里又容
易引起质疑，补充下，[i...j] 小于 0，即 [i...m] + [m+1...j] 小于 0，则如果 [i...m] 大于 [j+1...n]，因为 [i...j] 是负数，所
以 [i...m] 便大于 [i...n]，因为 [p...q] 跨越了 [i...j] 和 [j+1...k]，所以 [i...m] > [p...q]，不论 p、q 处在何种位置）。
如果反过来则是 array[j+1...n] > array[p...q]。所以不管谁大，我们都能够找到比 array[p...q] 更大的子串，与假设矛盾。所以满足条件
的 array[p...q] 不可能跨越两个子串。
对于跨越很多其它子串的情况，因为各子串的区间和均为负值。所以一样能证明存在更大的非跨越子串。

根据上面的证明过程，就有了 Kadane 算法的大概流程，先遍历数组，将其切割为第二个结论描述的子串，同时算出各子串的最大前缀和并比較得出答案。
以 array = {−2, 1, −3, 4, −1, 2, 1, −5, 4} 为例简单说明一下算法步骤。通过遍历将数组切割为例如以下 3 个子串（-2）。（1。-3），
（4。-1，2，1，-5，4）。各子串的最大前缀和分别是 -2，1，6，则答案为 6。
切割方法：遍历数组的同时进行求和，只要求和小于 0 就进行一次切割并重置和为 0 开始下一组。
网上也有称动态规划法的，其实和 kadane 是同一个算法。
*/

int main()
{
	int n[100], size;
	scanf_s("%d", &size);
	for (int i = 0; i < size; i++)	scanf_s("%d", &n[i]);
	printf("%d", maxSubArray(n, size));
	return 0;
}