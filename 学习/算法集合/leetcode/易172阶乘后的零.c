#include<stdio.h>
#include<stdlib.h>
/*
原题：
给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。
*/

int trailingZeroes(int n)
{
	int ans;
	for (ans = 0; n; n /= 5)	ans += n / 5;		//计算 n! 可以分解出多少个 5
	return ans;
}

int main()
{
	printf("%d", trailingZeroes(30));
	return 0;
}

/*
思路：
这道题难在数据上，样例中有大于 30 的阶乘计算，而即使是 long long 型也只能存到 20 的阶乘，因此靠暴力法是不可能通过本题所有样例的。
下面一步步分析出这道题的简便解法。
用括号内的 Y 代表 Y 次方，x 代表阶乘结果中去掉末尾 0 的部分，则结果可以表示为：
				x * 10（Y） = x * （2 * 5）（Y） = x * 2（Y） * 5（Y）
再注意观察阶乘公式： 1 * 2 * 3 ...... * n
稍微想想，就可以发现 Y 的大小取决于阶乘公式中有多少对 2 和 5，每对 2 和 5 便相当于乘了个 10，相当于一个 0。而从中分解 2 和 5 时，
显然 5 的个数要少于 2 的个数，所以问题就转化为阶乘公式中能分解出多少个 5。实际上，在 1 ~ n 中，对于 k 显然有 n / k 个 k 的倍数
（k 取整数），即在 1 ~ n 中，有 n / 5 个 5 的倍数。
虽然在 1 ~ n 中有 n / 5 个 5 的倍数，但并不代表 1 * 2 * 3 ...... * n 只能分解出 n / 5 个 5，如在 1 * 2 * 3 ...... * 30
中 25 能分解出两个 5，导致 30! 能够分解出 7 个 5，这是什么情况？
其实很简单，是因为 30 > 5 * 5 所以才有这种情况，再往后还有 5 * 5 * 2 = 50、5 * 5 * 3 = 75 等等，然而要解决这个问题很简单，因
为它们都是 5 的倍数，所以将 n / 5 得到的结果继续除 5，累加个数直到 n / 5 = 0 就可以得到 n! 中能分解出多少个 5。
*/