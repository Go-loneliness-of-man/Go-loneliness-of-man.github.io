#include<stdio.h>
//求斐波那契数列

/*
//算法一：利用递归计算
long fun(int x);
int main()
{
	int n;												//确定计算数列的前 n 项
	printf("请输入要输出的项数：");
	scanf_s("%d", &n);
	printf("\n斐波那契数列前 %d 项为：\n", n);
	for (int i = 1; i <= n; i++)
	{
		printf("\t%d", fun(i));
		if (i % 5 == 0)									//为了格式，每输出 5 个，换行
			printf("\n");
	}
	return 0;
}
long fun(int x)
{
	return x <= 2 ? 1 : (fun(x - 1) + fun(x - 2));		//第一、二个值为 1，从第三个起，每项的值与前两项的值有关
}
/*
思路:
这是最直观的一种方法。
关键点在于 fun() 函数的递归，从第三个起，是一种分解计算，比如第三项，递归一次分解为计算第二项和第一项。而拿第十项举例，递归一次后分为计算第九项和第
八项，而第八项可分解为第七项和第六项，第九项能分解成第八项和第七项，依此类推直到分解到第二项和第一项得出结果。从第三个起每个都是这样计算的，可以发现
这种算法大部分都是重复计算，且越往后重复的计算量越大，所以是种效率极低的计算方法。
*/

/*
//算法二：利用数组进行计算
#include<stdio.h>
int n, nums[100], i;								//确定计算数列的前 n 项
int main()
{
	printf("请输入要输出的项数：");
	scanf_s("%d", &n);
	printf("\n斐波那契数列前 %d 项为：\n", n);
	for (nums[1] = 1, nums[2] = 1, i = 3; i < n + 1; i++) nums[i] = nums[i - 1] + nums[i - 2];
	//一次性计算出前 n 项
	for (i = 1; i <= n; i++)
	{
		printf("\t%d", nums[i]);
		if (i % 5 == 0)					//为了格式，每输出 5 个，换行
			printf("\n");
	}
	return 0;
}
/*
思路：
将数列存放在一个数组中，得到 n 后开始计算，先定义第一个和第二个数组元素为 1，之后的每个等于前两项之和。
这个算法简单粗暴，没有大量的重复计算，也符合斐波那契数列原本的定义。是个不错的算法。
再往下还可以通过推导通项公式、利用矩阵、线性代数等方法来计算，那就属于数学的范畴了，我数学不好，暂时就写到这了。
*/