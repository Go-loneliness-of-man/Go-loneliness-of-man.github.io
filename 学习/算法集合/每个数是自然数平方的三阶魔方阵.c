#include <stdio.h>
//魔方阵，即每一行、每一列、对角线之和都相等的数字矩阵，三阶指三行三列。现求每个数字是自然数平方的所有三阶魔方阵。
//我自己花了一个多小时设计的这个程序用的是很烂很暴力的算法，有没有大佬有更好的方法......
int  main()
{
	int xx1, xx2, xx3, yy1, yy2, yy3, zz1, zz2, zz3, n[3][3], *x1, *x2, *x3, *y1, *y2, *y3, *z1, *z2, *z3, i, j, count = 0;
	//九个位置上的值、二维数组、九个位置对应的指针变量、循环打印变量 i , j、统计方阵数量的 count
	#define X ((*x1==1||*x1==4||*x1==9) && (*x2==1||*x2==4||*x2==9) && (*x3==1||*x3==4||*x3==9))
	#define Y ((*y1==1||*y1==4||*y1==9) && (*y2==1||*y2==4||*y2==9) && (*y3==1||*y3==4||*y3==9))
	#define Z ((*z1==1||*z1==4||*z1==9) && (*z2==1||*z2==4||*z2==9) && (*z3==1||*z3==4||*z3==9))
	#define ROW ((*x1+*x2+*x3)==(*y1+*y2+*y3) && (*x1+*x2+*x3)==(*z1+*z2+*z3))
	#define COL ((*x1+*y1+*z1)==(*x2+*y2+*z2) && (*x1+*y1+*z1)==(*x3+*y3+*z3))
	#define DUI	((*x1+*y2+*z3)==(*z1+*y2+*x3))
	x1 = &n[0][0];	x2 = &n[0][1];	x3 = &n[0][2];
	y1 = &n[1][0];	y2 = &n[1][1];	y3 = &n[1][2];
	z1 = &n[2][0];	z2 = &n[2][1];	z3 = &n[2][2];
	for (xx1 = 1; xx1 < 10; xx1++)
	{
		*x1 = xx1;
		for (xx2 = 1; xx2 < 10; xx2++)
		{
			*x2 = xx2;
			for (xx3 = 1; xx3 < 10; xx3++)
			{
				*x3 = xx3;
				for (yy1 = 1; yy1 < 10; yy1++)
				{
					*y1 = yy1;
					for (yy2 = 1; yy2 < 10; yy2++)
					{
						*y2 = yy2;
						for (yy3 = 1; yy3 < 10; yy3++)
						{
							*y3 = yy3;
							for (zz1 = 1; zz1 < 10; zz1++)
							{
								*z1 = zz1;
								for (zz2 = 1; zz2 < 10; zz2++)
								{
									*z2 = zz2;
									for (zz3 = 1; zz3 < 10; zz3++)
									{
										*z3 = zz3;
										if (ROW && COL && DUI)				//判断是否满足条件
										{
											if (X)
											{
												if (Y)
												{
													if (Z)
													{
														count++;
														printf("\n 第 %d 个魔方阵:", count);	//计数
														for (i = 0; i < 3; i++)			//循环打印
														{
															if (i == 0)
																printf("\n ");
															for (j = 0; j < 3; j++)	printf("%d\t", n[i][j]);
															printf("\n ");
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return 0;
}